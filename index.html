
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-park-mail-ru/2024_2_VKatuny/api/docs.go (0.0%)</option>
				
				<option value="file1">github.com/go-park-mail-ru/2024_2_VKatuny/cmd/app/main.go (0.0%)</option>
				
				<option value="file2">github.com/go-park-mail-ru/2024_2_VKatuny/internal/configs/config.go (0.0%)</option>
				
				<option value="file3">github.com/go-park-mail-ru/2024_2_VKatuny/internal/logger/logger.go (0.0%)</option>
				
				<option value="file4">github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware/access_logger.go (0.0%)</option>
				
				<option value="file5">github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware/authorizationChecker.go (0.0%)</option>
				
				<option value="file6">github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware/context.go (0.0%)</option>
				
				<option value="file7">github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware/cors_headers.go (0.0%)</option>
				
				<option value="file8">github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware/panic.go (0.0%)</option>
				
				<option value="file9">github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware/requestMethods.go (0.0%)</option>
				
				<option value="file10">github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware/slug.go (0.0%)</option>
				
				<option value="file11">github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware/universalMarshal.go (0.0%)</option>
				
				<option value="file12">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/delivery/applicant_handlers.go (0.0%)</option>
				
				<option value="file13">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/delivery/applicant_profile.go (0.0%)</option>
				
				<option value="file14">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/repository/applicant_inmem.go (0.0%)</option>
				
				<option value="file15">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/repository/applicant_postgres.go (0.0%)</option>
				
				<option value="file16">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/usecase/applicant_profile.go (0.0%)</option>
				
				<option value="file17">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/usecase/applicant_usecase.go (0.0%)</option>
				
				<option value="file18">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/cvs/delivery/cvs_handlers.go (0.0%)</option>
				
				<option value="file19">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/cvs/repository/cv_postgres.go (0.0%)</option>
				
				<option value="file20">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/cvs/usecase/cvs.go (0.0%)</option>
				
				<option value="file21">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/delivery/employer_handlers.go (0.0%)</option>
				
				<option value="file22">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/delivery/employer_profile.go (0.0%)</option>
				
				<option value="file23">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/repository/employer_inmem.go (0.0%)</option>
				
				<option value="file24">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/repository/employer_postgres.go (0.0%)</option>
				
				<option value="file25">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/usecase/employer_profile_usecase.go (0.0%)</option>
				
				<option value="file26">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/usecase/employer_usecase.go (0.0%)</option>
				
				<option value="file27">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/portfolio/repository/portfolio_postgres.go (0.0%)</option>
				
				<option value="file28">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/portfolio/usecase/portfolio.go (0.0%)</option>
				
				<option value="file29">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/delivery/session_handlers.go (0.0%)</option>
				
				<option value="file30">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/repository/session_inmem.go (0.0%)</option>
				
				<option value="file31">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/repository/session_postgres.go (0.0%)</option>
				
				<option value="file32">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/usecase/session_usecase.go (0.0%)</option>
				
				<option value="file33">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/delivery/vacancies_handlers.go (0.0%)</option>
				
				<option value="file34">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/delivery/vacancy.go (0.0%)</option>
				
				<option value="file35">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/repository/vacancies_inmem.go (0.0%)</option>
				
				<option value="file36">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/repository/vacancies_postgres.go (70.4%)</option>
				
				<option value="file37">github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/usecase/vacancies_usecase.go (0.0%)</option>
				
				<option value="file38">github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils/cookiegen.go (0.0%)</option>
				
				<option value="file39">github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils/db_conn.go (0.0%)</option>
				
				<option value="file40">github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils/passwordHash.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package api Code generated by swaggo/swag. DO NOT EDIT
package api

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Ifelsik",
            "url": "https://github.com/Ifelsik"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/authorized": {
            "post": {
                "description": "Gets cookie from user and checks authentication",
                "tags": [
                    "AuthStatus"
                ],
                "summary": "Checks user's authorization",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session ID (Cookie)",
                        "name": "session_id",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "Unauthorized"
                    }
                }
            }
        },
        "/login/": {
            "post": {
                "description": "-",
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "Login"
                ],
                "summary": "Realises authentication",
                "parameters": [
                    {
                        "description": "User's email",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    },
                    {
                        "description": "User's password",
                        "name": "password",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/logout/": {
            "post": {
                "description": "-",
                "tags": [
                    "Logout"
                ],
                "summary": "Realises deauthentication",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session ID (Cookie)",
                        "name": "session_id",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "Bad Request"
                    },
                    "401": {
                        "description": "Unauthorized"
                    }
                }
            }
        },
        "/registration/employer/": {
            "post": {
                "description": "-",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Registration"
                ],
                "summary": "Creates a new user as a employer",
                "parameters": [
                    {
                        "description": "User's email",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    },
                    {
                        "description": "User's password",
                        "name": "password",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/BD.UserInput"
                        }
                    },
                    "400": {
                        "description": "Bad Request"
                    }
                }
            }
        },
        "/registration/worker/": {
            "post": {
                "description": "-",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Registration"
                ],
                "summary": "Creates a new user as a worker",
                "parameters": [
                    {
                        "description": "User's email",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    },
                    {
                        "description": "User's password",
                        "name": "password",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/BD.UserInput"
                        }
                    },
                    "400": {
                        "description": "Bad Request"
                    }
                }
            }
        },
        "/vacancies": {
            "get": {
                "description": "Accepts offset and number of vacancies with id \u003e= offset. Returns vacancies",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Vacancies"
                ],
                "summary": "Gets list of vacancies",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "offset",
                        "name": "offset",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "num",
                        "name": "num",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "{\"status\": 200, \"vacancies\": [{\"id\": 1, \"position\": \"Продавец\", \"description\": \"Описание\", \"salary\": \"100\", \"employer\": \"Магазин\", \"location\": \"Tokyo\", \"createdAt\": \"2024.09.30 13:47:45\"}]}",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "400": {
                        "description": "{\"status\": 400, \"error\": \"num isn't number\"}",
                        "schema": {
                            "$ref": "#/definitions/handler.badResponse"
                        }
                    },
                    "405": {
                        "description": "{\"status\": 405, \"error\": \"http request method isn't a GET\"}",
                        "schema": {
                            "$ref": "#/definitions/handler.badResponse"
                        }
                    },
                    "500": {
                        "description": "{\"status\": 500, \"error\": \"encoding error\"}",
                        "schema": {
                            "$ref": "#/definitions/handler.badResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "BD.UserInput": {
            "type": "object",
            "properties": {
                "login": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "userType": {
                    "type": "string"
                }
            }
        },
        "handler.badResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "127.0.0.1:8000",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "uArt's API",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package main starts server and all handlers
package main

import (
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/configs"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/logger"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware"
        applicant_delivery "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/delivery"
        applicant_repository "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/repository"
        applicantUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/usecase"
        cvDelivery "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/cvs/delivery"
        cvRepository "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/cvs/repository"
        cvUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/cvs/usecase"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils"

        employer_delivery "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/delivery"
        employer_repository "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/repository"
        employerUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/usecase"
        portfolioRepository "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/portfolio/repository"
        portfolioUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/portfolio/usecase"
        session_delivery "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/delivery"
        session_repository "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/repository"
        vacancies_delivery "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/delivery"
        vacanciesUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/usecase"

        // "github.com/go-park-mail-ru/2024_2_VKatuny/internal"

        //vacancies_repostory "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/repository"

        _ "github.com/jackc/pgx/v5/stdlib"

        vacancies_repository "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/repository"
        //worker_delivery "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/worker/delivery"
        //worker_repository "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/worker/repository"
)

// @title   uArt's API
// @version 1.0

// @contact.name Ifelsik
// @contact.url  https://github.com/Ifelsik

// @host     127.0.0.1:8080
// @BasePath /api/v1
func main() <span class="cov0" title="0">{
        conf, _ := configs.ReadConfig("./configs/conf.yml")
        logger := logger.NewLogrusLogger()

        dbConnection, err := utils.GetDBConnection(conf.DataBase.GetDSN()) 
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err.Error())
        }</span>
        <span class="cov0" title="0">defer dbConnection.Close()

        Mux := http.NewServeMux()

        //applicantRepository := applicant_repository.NewRepo()
        applicantRepository := applicant_repository.NewApplicantStorage(dbConnection)
        sessionApplicantRepository, sessionEmployerRepository := session_repository.NewSessionStorage(dbConnection) // just do it!

        applicantHandler := applicant_delivery.CreateApplicantHandler(applicantRepository, sessionApplicantRepository, conf.Server.GetAddress())
        Mux.Handle("/api/v1/registration/applicant", applicantHandler)

        //employerRepository := employer_repository.NewRepo()
        employerRepository := employer_repository.NewEmployerStorage(dbConnection)

        employerHandler := employer_delivery.CreateEmployerHandler(employerRepository, sessionEmployerRepository, conf.Server.GetAddress())
        Mux.Handle("/api/v1/registration/employer", employerHandler)

        //sessionApplicantRepository, sessionEmployerRepository := session_repository.NewRepo() // just do it!

        loginHandler := session_delivery.LoginHandler(
                sessionApplicantRepository,
                sessionEmployerRepository,
                applicantRepository,
                employerRepository,
                conf.Server.GetAddress(),
        )
        Mux.Handle("/api/v1/login", loginHandler)

        logoutHandler := session_delivery.LogoutHandler(sessionApplicantRepository,
                sessionEmployerRepository,
                applicantRepository,
                employerRepository)
        Mux.Handle("/api/v1/logout", logoutHandler)

        authorizedHandler := session_delivery.AuthorizedHandler(sessionApplicantRepository,
                sessionEmployerRepository,
                applicantRepository,
                employerRepository)
        Mux.Handle("/api/v1/authorized", authorizedHandler)

        // TODO: should be from db
        vacanciesRepository := vacancies_repository.NewVacanciesStorage(dbConnection)
        vacanciesListHandler := vacancies_delivery.GetVacanciesHandler(vacanciesRepository) //(&amp;db.Vacancies)
        Mux.Handle("/api/v1/vacancies", vacanciesListHandler)

        repositories := &amp;internal.Repositories{
                ApplicantRepository:        applicantRepository,
                PortfolioRepository:        portfolioRepository.NewPortfolioStorage(dbConnection),
                CVRepository:               cvRepository.NewCVStorage(dbConnection),
                VacanciesRepository:        vacanciesRepository,
                EmployerRepository:         employerRepository,
                SessionApplicantRepository: sessionApplicantRepository,
                SessionEmployerRepository:  sessionEmployerRepository,
        }
        usecases := &amp;internal.Usecases{
                ApplicantUsecase: applicantUsecase.NewApplicantUsecase(logger, repositories),
                PortfolioUsecase: portfolioUsecase.NewPortfolioUsecase(logger, repositories),
                CVUsecase:        cvUsecase.NewCVsUsecase(logger, repositories),
                VacanciesUsecase: vacanciesUsecase.NewVacanciesUsecase(logger, repositories),
                EmployerUsecase:  employerUsecase.NewEmployerUsecase(logger, repositories),
        }
        app := &amp;internal.App{
                Logger:       logger,
                Repositories: repositories,
                Usecases:     usecases,
        }

        applicantProfileHandlers, err := applicant_delivery.NewApplicantProfileHandlers(logger, usecases)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>
        <span class="cov0" title="0">Mux.HandleFunc("/api/v1/applicant/profile/", applicantProfileHandlers.ApplicantProfileHandler)
        Mux.HandleFunc("/api/v1/applicant/portfolio/", applicantProfileHandlers.GetApplicantPortfoliosHandler)
        Mux.HandleFunc("/api/v1/applicant/cv/", applicantProfileHandlers.GetApplicantCVsHandler)

        employerProfileHandlers, err := employer_delivery.NewEmployerProfileHandlers(logger, usecases)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>
        <span class="cov0" title="0">Mux.HandleFunc("/api/v1/employer/profile/", employerProfileHandlers.EmployerProfileHandler)
        Mux.HandleFunc("/api/v1/employer/vacancies/", employerProfileHandlers.GetEmployerVacanciesHandler)

        cvsHandlers := cvDelivery.NewCVsHandler(app)
        Mux.HandleFunc("/api/v1/cv/", cvsHandlers.CVsRESTHandler)

        vacanciesHandlers := vacancies_delivery.NewVacanciesHandlers(app)
        Mux.HandleFunc("/api/v1/vacancy/", vacanciesHandlers.VacanciesRESTHandler)
        Mux.HandleFunc("/api/v1/vacancy/subscription/", vacanciesHandlers.VacanciesSubscribeRESTHandler)
        Mux.HandleFunc("/api/v1/vacancy/subscribers/", vacanciesHandlers.GetVacancySubscribersHandler)

        // Wrapped multiplexer
        // Mux implements http.Handler interface so it's possible to wrap
        handlers := middleware.SetSecurityAndOptionsHeaders(Mux, conf.Server.GetFrontURI())
        handlers = middleware.Panic(handlers)
        handlers = middleware.AccessLogger(handlers, logger)
        handlers = middleware.SetContext(handlers, logger)
        logger.Infof("Server is starting at %s", conf.Server.GetAddress())
        err = http.ListenAndServe(conf.Server.GetAddress(), handlers)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package configs contains configs of project
package configs

import (
        "fmt"
        "log"
        "os"
        "strconv"

        yaml "gopkg.in/yaml.v2"
)

// Config is a struct of .yaml config file
type Config struct {
        Server   *ServerConfig   `yaml:"server"`
        DataBase *DataBaseConfig `yaml:"database"`
}

// ServerConfig is a struct of server config block in .yaml
type ServerConfig struct {
        Scheme string `yaml:"scheme"`
        Host   string `yaml:"host"`
        Port   int    `yaml:"port"`
        Front  string `yaml:"frontURI"`
}

type DataBaseConfig struct {
        Host              string `yaml:"host"`
        Port              int    `yaml:"port"`
        User              string `yaml:"user"`
        Password          string `yaml:"password"`
        Schema            string `yaml:"schema"`
        DBName            string `yaml:"db_name"`
        SSLMode           string `yaml:"ssl_mode"`
        ConnectionTimeout string `yaml:"conn_timeout,omitempty"`  // Temporary unused
}

// ReadConfig reads file with configuration.
// Accepts path to .yaml config.
// Returns pointer to Config.
func ReadConfig(confPath string) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(confPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to read config file: %s", confPath)
                return nil, err
        }</span>

        <span class="cov0" title="0">var conf *Config
        err = yaml.Unmarshal(data, &amp;conf)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("unable to unmarshal config file")
        }</span>

        <span class="cov0" title="0">if conf.DataBase.ConnectionTimeout == "" </span><span class="cov0" title="0">{
                conf.DataBase.ConnectionTimeout = "60s"
        }</span>

        <span class="cov0" title="0">return conf, nil</span>
}

// GetAddress returns address of server
func (s *ServerConfig) GetAddress() string <span class="cov0" title="0">{
        return s.Host + ":" + strconv.Itoa(s.Port)
}</span>

// GetHostWithScheme returns host with scheme and port
// e.g. http://127.0.0.1:8080
func (s *ServerConfig) GetHostWithScheme() string <span class="cov0" title="0">{
        return s.Scheme + "://" + s.Host
}</span>

// GetFrontURI returns front uri. E.g http://127.0.0.1:3000
func (s *ServerConfig) GetFrontURI() string <span class="cov0" title="0">{
        return s.Front
}</span>

func (d *DataBaseConfig) GetDSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("user=%s dbname=%s password=%s host=%s port=%d sslmode=%s",
                d.User,
                d.DBName,
                d.Password,
                d.Host,
                d.Port,
                d.SSLMode,
        )
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package logger

import (
        "os"

        "github.com/sirupsen/logrus"
)

func NewLogrusLogger() *logrus.Logger <span class="cov0" title="0">{
        logger := &amp;logrus.Logger{
                Out:          os.Stdout,
                Formatter:    &amp;logrus.TextFormatter{
                        ForceColors: true,
                        FullTimestamp: true,
                        DisableLevelTruncation: true,
                        PadLevelText: true,
                        TimestampFormat: "2006.01.02 15:04:05",  // default go time format
                },
                ReportCaller: true,
                Level:        logrus.DebugLevel,
        }
        return logger
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package middleware ontains middleware of project
package middleware

import (
        "net/http"
        "time"

        "github.com/sirupsen/logrus"
)

// AccessLogger logs incoming requests
func AccessLogger(next http.Handler, logger *logrus.Logger) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func (w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                logger.WithFields(logrus.Fields{
                        "method": r.Method,
                        "path":   r.URL.Path,
                }).Info("Request received")
                start := time.Now()
                next.ServeHTTP(w, r)
                logger.WithFields(logrus.Fields{
                        "method": r.Method,
                        "path":   r.URL.Path,
                        // "status": w.Status(), how to get response status?
                        "elapsed": time.Since(start),
                }).Info("Response")
        }</span>)
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils"
        "github.com/sirupsen/logrus"
)

// TODO: make access to repositories from context
func RequireAuthorization(next dto.HandlerFunc, repositories *internal.Repositories, userType string) dto.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("WARNING: Can't get logger from context. Processing without it")
                }</span>
                <span class="cov0" title="0">logger.Debug("got logger from context")

                session, err := r.Cookie(dto.SessionIDName)
                if err == http.ErrNoCookie || session.Value == "" </span><span class="cov0" title="0">{
                        logger.Errorf("checking session: got err %s", err)
                        UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                                HTTPStatus: http.StatusUnauthorized,
                                Error:      err.Error(),
                        })
                        return
                }</span>

                // Getting userType from session
                <span class="cov0" title="0">userTypeGot, err := utils.CheckToken(session.Value)
                logger.Debugf("got user type %s with token %s", userTypeGot, session.Value)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("got err %s", err)
                        UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                                HTTPStatus: http.StatusUnauthorized,
                                Error:      err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">if userTypeGot != userType </span><span class="cov0" title="0">{
                        logger.Errorf("forbidden: got user type %s, expected %s", userTypeGot, userType)
                        UniversalMarshal(w, http.StatusForbidden, dto.JSONResponse{
                                HTTPStatus: http.StatusForbidden,
                                Error:      fmt.Errorf("got user type %s, expected %s", userTypeGot, userType).Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">var userID uint64
                if userType == dto.UserTypeApplicant </span><span class="cov0" title="0">{
                        userID, err = repositories.SessionApplicantRepository.GetUserIdBySession(session.Value)
                }</span> else<span class="cov0" title="0"> if userType == dto.UserTypeEmployer </span><span class="cov0" title="0">{
                        userID, err = repositories.SessionEmployerRepository.GetUserIdBySession(session.Value)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("got err %s", err)
                        UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                                HTTPStatus: http.StatusUnauthorized,
                                Error:      err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">ctx := r.Context()
                ctx = context.WithValue(ctx, dto.UserContextKey, &amp;dto.SessionUser{
                        ID:       userID,
                        UserType: userType,
                })
                next(w, r.WithContext(ctx))</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "context"
        "net/http"
        "github.com/sirupsen/logrus"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
)

// SetContext adds logger to the context
// and put into the handler
func SetContext(next http.Handler, logger *logrus.Logger) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                logger.Debug("Setting up context")
                ctx := r.Context()
                ctx = context.WithValue(ctx, dto.LoggerContextKey, logger)
                next.ServeHTTP(w, r.WithContext(ctx))
        }</span>)
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "net/http"
)

// SetSecurityAndOptionsHeaders Accepts function next and sets up CORS and content-type headers
// Returns wrapped function next with headers
func SetSecurityAndOptionsHeaders(next http.Handler, frontURI string) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set up CORS headers
                w.Header().Set("Access-Control-Allow-Origin", frontURI)
                w.Header().Set("Access-Control-Allow-Credentials", "true")
                w.Header().Set("Access-Control-Allow-Methods", "POST, GET, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Accept")

                if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        return
                }</span>
                // Set up content-type header
                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")

                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "fmt"
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/sirupsen/logrus"
)

// Panic recovers http.handler's panic.
// Accepts covering http.Handler.
// Returns http.Handler.
func Panic(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                funcName := "midleware.Panic"
                logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("%s: can't get logger from context\n", funcName)
                }</span>
                <span class="cov0" title="0">logger.Debugf("%s: entering", funcName)
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("%s: recovered panic: %v", funcName, err)
                                http.Error(w, "Internal server error", 500)
                        }</span>
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/sirupsen/logrus"
)

// AllowMethods checks if request method is allowed.
// Accepts http.Handler and allowed methods.
func AllowMethods(next http.Handler, allowedMethods ...string) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                fn := "middleware.AllowMethods"

                logger := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
                if logger == nil </span><span class="cov0" title="0">{
                        fmt.Printf("function %s: unable to get logger from context. Processing without it", fn)
                }</span>

                <span class="cov0" title="0">for _, allowedMethod := range allowedMethods </span><span class="cov0" title="0">{
                        // compares methods without case
                        if strings.EqualFold(r.Method, allowedMethod) </span><span class="cov0" title="0">{
                                logger.Debugf("function %s: method %s is allowed", fn, r.Method)
                                next.ServeHTTP(w, r)
                                return
                        }</span>
                }
                
                <span class="cov0" title="0">logger.Debugf("function %s: method %s is not allowed", fn, r.Method)
                UniversalMarshal(w, http.StatusMethodNotAllowed, dto.JSONResponse{
                        HTTPStatus: http.StatusMethodNotAllowed,
                        Error:      http.StatusText(http.StatusMethodNotAllowed),
                })</span>
        })
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strconv"
        "strings"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
)

var (
        ErrorSlug = fmt.Errorf("something bad with slug")
)

func GetIDSlugAtEnd(w http.ResponseWriter, r *http.Request, prefix string) (int, error) <span class="cov0" title="0">{
        url := r.URL.Path[len(prefix):]
        slug := strings.Split(url, "/")
        ID, err := strconv.Atoi(slug[0])
        if err != nil || len(slug) &gt; 1 </span><span class="cov0" title="0">{
                // h.logger.Errorf("function %s: got err %s", fn, ErrorSlug)
                UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                        HTTPStatus: http.StatusBadRequest,
                        Error:      ErrorSlug.Error(),
                })
                return 0, ErrorSlug
        }</span>
        <span class="cov0" title="0">return ID, nil</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "encoding/json"
        "fmt"
        "net/http"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
)

// UniversalMarshal marshal any struct to json (use it for any answer from handlers).
// Writes http status to http.ResponseWriter
func UniversalMarshal(w http.ResponseWriter, status int, body interface{}) error <span class="cov0" title="0">{
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(body); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf(dto.MsgUnableToMarshalJSON)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package delivery

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/repository"
        applicantUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/usecase"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        sessionRepo "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils"
        "github.com/sirupsen/logrus"
)

// CreateWorkerHandler creates applicant in db
// CreateWorker godoc
// @Summary     Creates a new user as a applicant
// @Description -
// @Tags        Registration
// @Accept      json
// @Produce     json
// @Param       email    body string true "User's email"
// @Param       password body string true "User's password"
// @Success     200 {object} inmemorydb.UserInput
// @Failure     http.StatusBadRequest {object} nil
// @Router      /registration/applicant/ [post]
func CreateApplicantHandler(repo repository.IApplicantRepository, repoApplicantSession sessionRepo.SessionRepository, backendAddress string) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer r.Body.Close()

                funcName := "CreateApplicantHandler"
                logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("function %s: can't get logger from context\n", funcName)
                        return
                }</span>

                <span class="cov0" title="0">decoder := json.NewDecoder(r.Body)

                newUserInput := new(dto.ApplicantInput)
                err := decoder.Decode(newUserInput)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("function %s: got err %s", funcName, err)
                        middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      dto.MsgInvalidJSON,
                        })
                        return
                }</span>

                <span class="cov0" title="0">if err := applicantUsecase.CreateApplicantInputCheck(newUserInput.FirstName, newUserInput.LastName, newUserInput.Email, newUserInput.Password); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("function %s: %s", funcName, err.Error())
                        middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      "user's fields aren't valid", // TODO: refactor error after refactoring validation
                        })
                        return
                }</span>

                <span class="cov0" title="0">logger.Debugf("function %s: adding applicant to db %v", funcName, newUserInput)
                // TODO: creating applicant and adding created session with new user must be in different usecases. divide usecase
                user, sessionID, err := applicantUsecase.CreateApplicant(repo, repoApplicantSession, newUserInput)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("function %s: err - %s", funcName, err)
                        middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                                HTTPStatus: http.StatusInternalServerError,
                                Error:      err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">logger.Debug("Cookie send")
                cookie := utils.MakeAuthCookie(sessionID, backendAddress)
                http.SetCookie(w, cookie)
                // TODO: refactor code below

                // if err == nil {
                //         user.UserType = dto.UserTypeApplicant
                //         middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                //                 HTTPStatus: http.StatusOK,
                //                 Body:       user,
                //         })
                // } else {
                //         // is there actually should be HTTP 400?
                //         logger.Errorf("function %s: got err while adding applicant to db %s", funcName, err)
                //         middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                //                 HTTPStatus: http.StatusInternalServerError,
                //                 Error:      err.Error(),
                //         })
                // }
                user.UserType = dto.UserTypeApplicant
                middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                        HTTPStatus: http.StatusOK,
                        Body:       user,
                })</span>
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package delivery

import (
        "encoding/json"
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware"
        applicantUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/usecase"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/commonerrors"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/cvs"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        portfolioUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/portfolio/usecase"
        "github.com/sirupsen/logrus"
)

type ApplicantProfileHandlers struct {
        logger           *logrus.Logger
        applicantUsecase applicantUsecase.IApplicantUsecase
        portfolioUsecase portfolioUsecase.IPortfolioUsecase
        cvUsecase        cvs.ICVsUsecase
}

func NewApplicantProfileHandlers(logger *logrus.Logger, usecases *internal.Usecases) (*ApplicantProfileHandlers, error) <span class="cov0" title="0">{
        ApplicantUsecase, ok1 := usecases.ApplicantUsecase.(*applicantUsecase.ApplicantUsecase)
        PortfolioUsecase, ok2 := usecases.PortfolioUsecase.(*portfolioUsecase.PortfolioUsecase)
        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                return nil, commonerrors.ErrUnableToCast
        }</span>
        <span class="cov0" title="0">return &amp;ApplicantProfileHandlers{
                logger:           logger,
                applicantUsecase: ApplicantUsecase,
                portfolioUsecase: PortfolioUsecase,
                cvUsecase:        usecases.CVUsecase,
        }, nil</span>
}

func (h *ApplicantProfileHandlers) ApplicantProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        //h.logger.Debug("1---------------------------------", r.URL.Path)
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.GetApplicantProfileHandler(w, r)</span>
        case http.MethodPut:<span class="cov0" title="0">
                h.UpdateApplicantProfileHandler(w, r)</span>
        default:<span class="cov0" title="0">
                middleware.UniversalMarshal(w, http.StatusMethodNotAllowed, dto.JSONResponse{
                        HTTPStatus: http.StatusMethodNotAllowed,
                        Error:      http.StatusText(http.StatusMethodNotAllowed),
                })</span>
        }
}

func (h *ApplicantProfileHandlers) GetApplicantProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "ApplicantProfileHandlers.GetApplicantProfileHandler"

        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/applicant/profile/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>

        <span class="cov0" title="0">applicantID := uint64(ID)
        // dto - JSONGetApplicantProfile
        applicantProfile, err := h.applicantUsecase.GetApplicantProfile(applicantID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debugf("function %s: success, got profile %v", fn, applicantProfile)
        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       applicantProfile,
        })</span>
}

func (h *ApplicantProfileHandlers) UpdateApplicantProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "ApplicantProfileHandlers.UpdateApplicantProfileHandler"

        // url := r.URL.Path[len("/api/v1/applicant/profile/"):]
        // slugID := strings.Split(url, "/")[0]
        // ID, err := strconv.Atoi(slugID)
        // if len(url) &lt; 1 || err != nil {
        //         h.logger.Errorf("function %s: something bad with slug", fn)
        //         middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
        //                 HTTPStatus: http.StatusBadRequest,
        //                 Error:      "something bad with slug",
        //         })
        //         return
        // }

        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/applicant/profile/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>

        <span class="cov0" title="0">applicantID := uint64(ID)

        decoder := json.NewDecoder(r.Body)
        newProfileData := new(dto.JSONUpdateApplicantProfile)
        err = decoder.Decode(newProfileData)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                        HTTPStatus: http.StatusBadRequest,
                        Error:      "unable to unmarshal JSON",
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.applicantUsecase.UpdateApplicantProfile(applicantID, newProfileData)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debugf("function %s: successfully updated profile", fn)
        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
        })</span>
}

func (h *ApplicantProfileHandlers) GetApplicantPortfoliosHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "ApplicantProfileHandlers.GetApplicantPortfoliosHandler"

        // url := r.URL.Path[len("/api/v1/applicant/portfolio/"):]
        // slugID := strings.Split(url, "/")[0]
        // ID, err := strconv.Atoi(slugID)
        // if len(url) &lt; 1 || err != nil {
        //         h.logger.Errorf("function %s: something bad with slug", fn)
        //         middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
        //                 HTTPStatus: http.StatusBadRequest,
        //                 Error:      "something bad with slug",
        //         })
        //         return
        // }
        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/applicant/portfolio/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>

        <span class="cov0" title="0">applicantID := uint64(ID)
        portfolios, err := h.portfolioUsecase.GetApplicantPortfolios(applicantID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debugf("function %s: success, got portfolios: %d", fn, len(portfolios))
        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       portfolios,
        })</span>
}

func (h *ApplicantProfileHandlers) GetApplicantCVsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "ApplicantProfileHandlers.GetApplicantCVsHandler"

        // url := r.URL.Path[len("/api/v1/applicant/cv/"):]
        // slugID := strings.Split(url, "/")[0]
        // ID, err := strconv.Atoi(slugID)
        // if len(url) &lt; 1 || err != nil {
        //         h.logger.Errorf("function %s: something bad with slug", fn)
        //         middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
        //                 HTTPStatus: http.StatusBadRequest,
        //                 Error:      "something bad with slug",
        //         })
        //         return
        // }
        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/applicant/cv/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>

        <span class="cov0" title="0">applicantID := uint64(ID)
        // *dto.JSONGetApplicantCV
        CVs, err := h.cvUsecase.GetApplicantCVs(applicantID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debugf("function %s: success, got CVs: %d", fn, len(CVs))
        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       CVs,
        })</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "time"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/models"
)

// DOES NOT SUPPORT ASYNC

// implementation of repository.applicant interface
// in-memory-db
type applicantRepo struct {
        lastID uint64
        data   []*models.Applicant
}

// Initialize new repo
// Returns pointer to it
func NewRepo() *applicantRepo <span class="cov0" title="0">{
        return &amp;applicantRepo{
                lastID: 1,
                data:   make([]*models.Applicant, 0, 10),
        }
}</span>

// Create new applicant into the db
// Accepts pointer to applicant model
// Returns ID of created applicant and error
func (repo *applicantRepo) Create(applicantInput *dto.ApplicantInput) (*models.Applicant, error) <span class="cov0" title="0">{

        applicant := &amp;models.Applicant{
                FirstName:           applicantInput.FirstName,
                LastName:            applicantInput.LastName,
                CityName:            applicantInput.CityName,
                BirthDate:           applicantInput.BirthDate,
                PathToProfileAvatar: applicantInput.PathToProfileAvatar,
                Contacts:            applicantInput.Contacts,
                Education:           applicantInput.Education,
                Email:               applicantInput.Email,
                PasswordHash:        applicantInput.Password,
                CreatedAt:           time.Now().Format(time.RFC3339),
                UpdatedAt:           time.Now().Format(time.RFC3339),
        }
        applicant.ID = repo.lastID
        repo.lastID++
        repo.data = append(repo.data, applicant)
        return applicant, nil
}</span>

// GetByID gets applicant by ID.
// BUG: If user with this ID doesn't exist panic can be raised
func (repo *applicantRepo) GetByID(id uint64) (*models.Applicant, error) <span class="cov0" title="0">{
        if id &gt; repo.lastID </span><span class="cov0" title="0">{
                // should return error!!
                // remade with own_errors
                return nil, nil
        }</span>
        <span class="cov0" title="0">return repo.data[id], nil</span>
}

func (repo *applicantRepo) GetByEmail(email string) (*models.Applicant, error) <span class="cov0" title="0">{
        for _, applicant := range repo.data </span><span class="cov0" title="0">{
                if applicant.Email == email </span><span class="cov0" title="0">{
                        return applicant, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, ErrNoUserExist</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/models"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
)

// PostgreSQLBoardStorage
// Хранилище досок в PostgreSQL
type PostgreSQLApplicantStorage struct {
        db *sql.DB
}

func NewApplicantStorage(db *sql.DB) *PostgreSQLApplicantStorage <span class="cov0" title="0">{
        return &amp;PostgreSQLApplicantStorage{
                db: db,
        }
}</span>

// GetByID
// находит доску и связанные с ней списки и задания по id
// или возвращает ошибки ...
func (s *PostgreSQLApplicantStorage) GetByID(id uint64) (*models.Applicant, error) <span class="cov0" title="0">{
        // funcName := "PostgreSQLapplicant.GetById"
        // logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
        // if !ok {
        //         fmt.Printf("function %s: can't get logger from context\n", funcName)
        // }

        //requestID := ctx.Value(dto.RequestIDKey).(uuid.UUID)

        //logger.DebugFmt("Built query\n\t"+boardSql+"\nwith args\n\t"+fmt.Sprintf("%+v", args), requestID.String(), funcName, nodeName)
        row := s.db.QueryRow(`select applicant.id, first_name, last_name, city.city_name, birth_date, path_to_profile_avatar, contacts, 
        education, email, password_hash, applicant.created_at, applicant.updated_at 
        from applicant left join city on applicant.city_id = city.id where applicant.id = $1`, id)

        var applicantWithNull dto.ApplicantWithNull
        err := row.Scan(
                &amp;applicantWithNull.ID,
                &amp;applicantWithNull.FirstName,
                &amp;applicantWithNull.LastName,
                &amp;applicantWithNull.CityName,
                &amp;applicantWithNull.BirthDate,
                &amp;applicantWithNull.PathToProfileAvatar,
                &amp;applicantWithNull.Contacts,
                &amp;applicantWithNull.Education,
                &amp;applicantWithNull.Email,
                &amp;applicantWithNull.PasswordHash,
                &amp;applicantWithNull.CreatedAt,
                &amp;applicantWithNull.UpdatedAt,
        )
        applicant := models.Applicant{
                ID:                  applicantWithNull.ID,
                FirstName:           applicantWithNull.FirstName,
                LastName:            applicantWithNull.LastName,
                CityName:            applicantWithNull.CityName.String,
                BirthDate:           applicantWithNull.BirthDate,
                PathToProfileAvatar: applicantWithNull.PathToProfileAvatar,
                Contacts:            applicantWithNull.Contacts.String,
                Education:           applicantWithNull.Education.String,
                Email:               applicantWithNull.Email,
                PasswordHash:        applicantWithNull.PasswordHash,
                CreatedAt:           applicantWithNull.CreatedAt,
                UpdatedAt:           applicantWithNull.UpdatedAt,
        }

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //logger.DebugFmt(fmt.Sprintf("%+v", board), requestID.String(), funcName, nodeName)

        <span class="cov0" title="0">return &amp;applicant, nil</span>
}

func (s *PostgreSQLApplicantStorage) GetByEmail(email string) (*models.Applicant, error) <span class="cov0" title="0">{
        //log.Println("Looking for user with login", login.Value)

        //log.Println("Built query:", sql, "\nwith args:", args)

        row := s.db.QueryRow(`select applicant.id, first_name, last_name, city.city_name, birth_date, path_to_profile_avatar, contacts, 
        education, email, password_hash, applicant.created_at, applicant.updated_at 
        from applicant left join city on applicant.city_id = city.id where applicant.email=$1`, email)

        var applicantWithNull dto.ApplicantWithNull
        err := row.Scan(
                &amp;applicantWithNull.ID,
                &amp;applicantWithNull.FirstName,
                &amp;applicantWithNull.LastName,
                &amp;applicantWithNull.CityName,
                &amp;applicantWithNull.BirthDate,
                &amp;applicantWithNull.PathToProfileAvatar,
                &amp;applicantWithNull.Contacts,
                &amp;applicantWithNull.Education,
                &amp;applicantWithNull.Email,
                &amp;applicantWithNull.PasswordHash,
                &amp;applicantWithNull.CreatedAt,
                &amp;applicantWithNull.UpdatedAt,
        )
        applicant := models.Applicant{
                ID:                  applicantWithNull.ID,
                FirstName:           applicantWithNull.FirstName,
                LastName:            applicantWithNull.LastName,
                CityName:            applicantWithNull.CityName.String,
                BirthDate:           applicantWithNull.BirthDate,
                PathToProfileAvatar: applicantWithNull.PathToProfileAvatar,
                Contacts:            applicantWithNull.Contacts.String,
                Education:           applicantWithNull.Education.String,
                Email:               applicantWithNull.Email,
                PasswordHash:        applicantWithNull.PasswordHash,
                CreatedAt:           applicantWithNull.CreatedAt,
                UpdatedAt:           applicantWithNull.UpdatedAt,
        }
        //log.Println(user)
        //log.Println(err)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error", err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;applicant, nil</span>
}

func (s *PostgreSQLApplicantStorage) Create(applicantInput *dto.ApplicantInput) (*models.Applicant, error) <span class="cov0" title="0">{

        _, err := s.db.Exec("insert into applicant (first_name, last_name, birth_date, education, email, password_hash) VALUES ($1, $2, $3, $4, $5, $6)",
                applicantInput.FirstName, applicantInput.LastName, applicantInput.BirthDate, applicantInput.Education, applicantInput.Email, applicantInput.Password)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">applicant, err := s.GetByEmail(applicantInput.Email)

        return applicant, err</span>
}

func (s *PostgreSQLApplicantStorage) Update(ID uint64, newApplicantData *dto.JSONUpdateApplicantProfile) error <span class="cov0" title="0">{

        var CityId int
        row := s.db.QueryRow(`select id from city where city_name=$1`, newApplicantData.City)
        if err := row.Scan(&amp;CityId); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        row = s.db.QueryRow(`insert into city (city_name) VALUES ($1) returning id`, newApplicantData.City)
                        err = row.Scan(&amp;CityId)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
        <span class="cov0" title="0">_, err := s.db.Exec(`update applicant
                set first_name = $1, last_name = $2, city_id = $3, birth_date=$4,
                contacts = $5, education = $6 where id=$7`,
                newApplicantData.FirstName, newApplicantData.LastName, CityId, newApplicantData.BirthDate, newApplicantData.Contacts, newApplicantData.Education, ID)
        return err</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package usecase

import (
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        applicantRepository "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/sirupsen/logrus"
)

type IApplicantUsecase interface {
        GetApplicantProfile(userID uint64) (*dto.JSONGetApplicantProfile, error)
        UpdateApplicantProfile(applicantID uint64, newProfileData *dto.JSONUpdateApplicantProfile) error
}

type ApplicantUsecase struct {
        logger        *logrus.Logger
        applicantRepo applicantRepository.IApplicantRepository // TODO: add prefix I to interface
}

func NewApplicantUsecase(logger *logrus.Logger, repositories *internal.Repositories) *ApplicantUsecase <span class="cov0" title="0">{
        ApplicantRepository, ok := repositories.ApplicantRepository.(applicantRepository.IApplicantRepository)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;ApplicantUsecase{
                logger:        logger,
                applicantRepo: ApplicantRepository,
        }</span>
}

// GetApplicantProfile accepts the profile of an applicant using the given userID.
// It logs the process of fetching the profile and returns the applicant profile data
// encapsulated in a JSONGetApplicantProfile DTO. If fetching the profile fails,
// it returns an error.
func (au *ApplicantUsecase) GetApplicantProfile(userID uint64) (*dto.JSONGetApplicantProfile, error) <span class="cov0" title="0">{
        fn := "ApplicantUsecase.GetApplicantProfile"

        au.logger.Debugf("function: %s; user id: %d. Trying to get applicant profile by id", fn, userID)
        applicantModel, err := au.applicantRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                au.logger.Errorf("function: %s; got err: %s", fn, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">au.logger.Debugf("function: %s; successfully got applicant profile: %v", fn, applicantModel)
        return &amp;dto.JSONGetApplicantProfile{
                ID:        applicantModel.ID,
                FirstName: applicantModel.FirstName,
                LastName:  applicantModel.LastName,
                City:      applicantModel.CityName,
                BirthDate: applicantModel.BirthDate,
                Contacts:  applicantModel.Contacts,
                Education: applicantModel.Education,
        }, nil</span>
}

// UpdateApplicantProfile updates the profile of an applicant with the given ID
// using the provided new profile data. It logs the update process and returns
// an error if the update fails.
func (au *ApplicantUsecase) UpdateApplicantProfile(applicantID uint64, newProfileData *dto.JSONUpdateApplicantProfile) error <span class="cov0" title="0">{
        fn := "ApplicantUsecase.UpdateApplicantProfile"

        au.logger.Debugf("function: %s; applicant id: %d. Trying to update applicant profile", fn, applicantID)

        err := au.applicantRepo.Update(applicantID, newProfileData)

        if err != nil </span><span class="cov0" title="0">{
                au.logger.Errorf("function: %s; got err: %s", fn, err)
                return err
        }</span>
        <span class="cov0" title="0">au.logger.Debugf("function: %s; successfully updated applicant profile", fn)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package usecase contains usecase for worker
package usecase

import (
        "fmt"
        "strings"

        repoApplicant "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        repoSession "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils"
)

// TODO: refactor valid code
func CreateApplicantInputCheck(Name, LastName, Email, Password string) error <span class="cov0" title="0">{
        if len(Name) &gt; 50 || len(LastName) &gt; 50 ||
                strings.Index(Email, "@") &lt; 0 || len(Password) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("applicant's fields aren't valid %s %s %s", Name, LastName, Email)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateApplicant accepts employer repository and validated form and creates new employer
func CreateApplicant(repo repoApplicant.IApplicantRepository, sessionRepoApplicant repoSession.SessionRepository, form *dto.ApplicantInput) (*dto.ApplicantOutput, string, error) <span class="cov0" title="0">{
        _, err := repo.GetByEmail(form.Email)
        // if applicant != nil {
        //         return nil, "", fmt.Errorf(dto.MsgUserAlreadyExists)
        // }
        // if err != nil {
        //         return nil, "", fmt.Errorf(dto.MsgDataBaseError)
        // }
        if err.Error() != "sql: no rows in result set" </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">form.Password = utils.HashPassword(form.Password)
        user, err := repo.Create(form)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">sessionID := utils.GenerateSessionToken(utils.TokenLength, dto.UserTypeApplicant)
        err = sessionRepoApplicant.Create(user.ID, sessionID)
        // if err != nil {
        //         return nil, "", fmt.Errorf(dto.MsgDataBaseError)
        // }
        return &amp;dto.ApplicantOutput{
                ID:                  user.ID,
                FirstName:           user.FirstName,
                LastName:            user.LastName,
                CityName:            user.CityName,
                BirthDate:           user.BirthDate,
                PathToProfileAvatar: user.PathToProfileAvatar,
                Contacts:            user.Contacts,
                Education:           user.Education,
                Email:               user.Email,
                CreatedAt:           user.CreatedAt,
                UpdatedAt:           user.UpdatedAt,
        }, sessionID, err</span> // TODO: return nil instead of err
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package delivery

import (
        "encoding/json"
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/commonerrors"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/cvs"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session"
        "github.com/sirupsen/logrus"
)

type CVsHandler struct {
        logger               *logrus.Logger
        cvsUsecase           cvs.ICVsUsecase
        sessionApplicantRepo session.ISessionRepository
}

func NewCVsHandler(layers *internal.App) *CVsHandler <span class="cov0" title="0">{
        logger := layers.Logger
        logger.Debug("CVsHandler created")
        return &amp;CVsHandler{
                logger:     logger,
                cvsUsecase: layers.Usecases.CVUsecase,
                sessionApplicantRepo: layers.Repositories.SessionApplicantRepository,
        }
}</span>

func (h *CVsHandler) CVsRESTHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debugf("CVsHandler.CVsRESTHandler got request: %s", r.URL.Path)
        repositories := &amp;internal.Repositories{SessionApplicantRepository: h.sessionApplicantRepo}
        switch r.Method </span>{
        case http.MethodPost:<span class="cov0" title="0">
                handler := middleware.RequireAuthorization(h.CreateCVHandler, repositories, dto.UserTypeApplicant)
                handler(w, r)</span>
        case http.MethodGet:<span class="cov0" title="0">
                h.GetCVsHandler(w, r)</span>
        case http.MethodPut:<span class="cov0" title="0">
                handler := middleware.RequireAuthorization(h.UpdateCVHandler, repositories, dto.UserTypeApplicant)
                handler(w, r)</span>
        case http.MethodDelete:<span class="cov0" title="0">
                handler := middleware.RequireAuthorization(h.DeleteCVHandler, repositories, dto.UserTypeApplicant)
                handler(w, r)</span>
        default:<span class="cov0" title="0">
                middleware.UniversalMarshal(w, http.StatusMethodNotAllowed, dto.JSONResponse{
                        HTTPStatus: http.StatusMethodNotAllowed,
                        Error:      dto.MsgMethodNotAllowed,
                })
                r.Body.Close()</span>
        }
}

func (h *CVsHandler) CreateCVHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "CVsHandler.CreateCVHandler"

        decoder := json.NewDecoder(r.Body)
        newCV := new(dto.JSONCv)

        err := decoder.Decode(newCV)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                        HTTPStatus: http.StatusBadRequest,
                        Error:      dto.MsgInvalidJSON,
                })
                return
        }</span>

        <span class="cov0" title="0">currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("unable to get user from context, please check didn't you forget to add middleware.RequireAuthorization")
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>

        <span class="cov0" title="0">wroteCV, err := h.cvsUsecase.CreateCV(newCV, currentUser)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">h.logger.Debugf("function %s: success, got created cv: %v", fn, wroteCV)

        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       wroteCV,
        })</span>
}

func (h *CVsHandler) GetCVsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "CVsHandler.GetCVsHandler"

        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/cv/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>
        <span class="cov0" title="0">h.logger.Debugf("function %s: got slug cvID: %d", fn, ID)

        cvID := uint64(ID)

        CV, err := h.cvsUsecase.GetCV(cvID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debugf("function %s: success, got cv: %v", fn, CV)
        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       CV,
        })</span>
}

func (h *CVsHandler) UpdateCVHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()
        fn := "CVsHandler.UpdateCVHandler"
        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/cv/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>
        <span class="cov0" title="0">h.logger.Debugf("function %s: got slug cvID: %d", fn, ID)
        cvID := uint64(ID)
        decoder := json.NewDecoder(r.Body)
        newCV := new(dto.JSONCv)
        err = decoder.Decode(newCV)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                        HTTPStatus: http.StatusBadRequest,
                        Error:      dto.MsgInvalidJSON,
                })
                return
        }</span>

        <span class="cov0" title="0">currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("unable to get user from context, please check didn't you forget to add middleware.RequireAuthorization")
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>

        <span class="cov0" title="0">updatedCV, err := h.cvsUsecase.UpdateCV(cvID, currentUser, newCV)
        if err == commonerrors.ErrUnauthorized || err == commonerrors.ErrSessionNotFound </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusUnauthorized,
                        Error:      err.Error(),
                })
                return
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debugf("function %s: success, got updated cv: %v", fn, updatedCV)

        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       updatedCV,
        })</span>
}

func (h *CVsHandler) DeleteCVHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "CVsHandler.DeleteCVHandler"
        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/cv/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>
        <span class="cov0" title="0">h.logger.Debugf("function %s: got slug cvID: %d", fn, ID)

        cvID := uint64(ID)

        currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("unable to get user from context, please check didn't you forget to add middleware.RequireAuthorization")
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.cvsUsecase.DeleteCV(cvID, currentUser)
        if err == commonerrors.ErrUnauthorized || err == commonerrors.ErrSessionNotFound </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusUnauthorized,
                        Error:      err.Error(),
                })
                return
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
        })</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
)

type PostgreSQLCVStorage struct {
        db *sql.DB
}

func NewCVStorage(db *sql.DB) *PostgreSQLCVStorage <span class="cov0" title="0">{
        return &amp;PostgreSQLCVStorage{
                db: db,
        }
}</span>

func (s *PostgreSQLCVStorage) GetCVsByApplicantID(applicantID uint64) ([]*dto.JSONCv, error) <span class="cov0" title="0">{

        CVs := make([]*dto.JSONCv, 0)

        rows, err := s.db.Query(`select cv.id, applicant_id, position_rus, position_eng, job_search_status_name, cv_description, working_experience,
                path_to_profile_avatar, cv.created_at, cv.updated_at  from cv left join job_search_status on job_search_status.id = cv.job_search_status_id 
                where cv.applicant_id = $1`, applicantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var CV dto.JSONCv
                if err := rows.Scan(&amp;CV.ID, &amp;CV.ApplicantID, &amp;CV.PositionRu, &amp;CV.PositionEn, &amp;CV.JobSearchStatusName, &amp;CV.Description, &amp;CV.WorkingExperience, &amp;CV.Avatar, &amp;CV.CreatedAt, &amp;CV.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">CVs = append(CVs, &amp;CV)
                fmt.Println(CV)</span>
        }

        <span class="cov0" title="0">return CVs, nil</span>
}

func (s *PostgreSQLCVStorage) Create(cv *dto.JSONCv) (*dto.JSONCv, error) <span class="cov0" title="0">{
        var JobSearchStatusID int
        row := s.db.QueryRow(`select id from job_search_status where job_search_status_name=$1`, cv.JobSearchStatusName)
        if err := row.Scan(&amp;JobSearchStatusID); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        row = s.db.QueryRow(`insert into job_search_status (job_search_status_name) VALUES ($1) returning id`, cv.JobSearchStatusName)
                        err = row.Scan(&amp;JobSearchStatusID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        <span class="cov0" title="0">var oneCv dto.JSONCv
        row = s.db.QueryRow(`insert into cv (applicant_id, position_rus, position_eng, cv_description, job_search_status_id, working_experience)
                VALUES ($1, $2, $3, $4, $5, $6) returning id, applicant_id, position_rus, position_eng,
                cv_description, working_experience, path_to_profile_avatar, created_at, updated_at`,
                cv.ApplicantID, cv.PositionRu, cv.PositionEn, cv.Description, JobSearchStatusID, cv.WorkingExperience)
        err := row.Scan(&amp;oneCv.ID,
                &amp;oneCv.ApplicantID,
                &amp;oneCv.PositionRu,
                &amp;oneCv.PositionEn,
                &amp;oneCv.Description,
                &amp;oneCv.WorkingExperience,
                &amp;oneCv.Avatar,
                &amp;oneCv.CreatedAt,
                &amp;oneCv.UpdatedAt)
        oneCv.JobSearchStatusName = cv.JobSearchStatusName
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;oneCv, err</span>
}

func (s *PostgreSQLCVStorage) GetByID(ID uint64) (*dto.JSONCv, error) <span class="cov0" title="0">{

        row := s.db.QueryRow(`select cv.id, applicant_id, position_rus, position_eng, job_search_status.job_search_status_name, cv_description, working_experience,
                path_to_profile_avatar, cv.created_at, cv.updated_at  from cv left join job_search_status on job_search_status.id = cv.job_search_status_id where cv.id = $1`, ID)
        var oneCv dto.JSONCv

        err := row.Scan(&amp;oneCv.ID,
                &amp;oneCv.ApplicantID,
                &amp;oneCv.PositionRu,
                &amp;oneCv.PositionEn,
                &amp;oneCv.JobSearchStatusName,
                &amp;oneCv.Description,
                &amp;oneCv.WorkingExperience,
                &amp;oneCv.Avatar,
                &amp;oneCv.CreatedAt,
                &amp;oneCv.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;oneCv, err</span>
}

func (s *PostgreSQLCVStorage) Update(ID uint64, updatedCv *dto.JSONCv) (*dto.JSONCv, error) <span class="cov0" title="0">{

        var JobSearchStatusID int
        row := s.db.QueryRow(`select id from job_search_status where job_search_status_name=$1`, updatedCv.JobSearchStatusName)
        if err := row.Scan(&amp;JobSearchStatusID); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        row = s.db.QueryRow(`insert into job_search_status (job_search_status_name) VALUES ($1) returning id`, updatedCv.JobSearchStatusName)
                        err = row.Scan(&amp;JobSearchStatusID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        <span class="cov0" title="0">row = s.db.QueryRow(`update cv
                set applicant_id = $1, position_rus = $2, position_eng = $3, cv_description=$4, 
                job_search_status_id = $5, working_experience = $6, path_to_profile_avatar=$7 where id=$8 returning id, 
                applicant_id, position_rus, position_eng, cv_description, working_experience, path_to_profile_avatar, created_at, updated_at`,
                updatedCv.ApplicantID, updatedCv.PositionRu, updatedCv.PositionEn, updatedCv.Description, JobSearchStatusID, updatedCv.WorkingExperience, updatedCv.Avatar, ID)

        var oneVacancy dto.JSONCv

        err := row.Scan(&amp;oneVacancy.ID,
                &amp;oneVacancy.ApplicantID,
                &amp;oneVacancy.PositionRu,
                &amp;oneVacancy.PositionEn,
                &amp;oneVacancy.Description,
                &amp;oneVacancy.WorkingExperience,
                &amp;oneVacancy.Avatar,
                &amp;oneVacancy.CreatedAt,
                &amp;oneVacancy.UpdatedAt)
        oneVacancy.JobSearchStatusName = updatedCv.JobSearchStatusName
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;oneVacancy, err</span>
}

func (s *PostgreSQLCVStorage) Delete(ID uint64) error <span class="cov0" title="0">{
        _, err := s.db.Exec(`delete from cv where id = $1`, ID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package usecase

import (
        "fmt"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/cvs"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session"
        "github.com/sirupsen/logrus"
)

type CVsUsecase struct {
        logger      *logrus.Logger
        cvsRepo     cvs.ICVsRepository
        sessionRepo session.ISessionRepository
}

func NewCVsUsecase(logger *logrus.Logger, repositories *internal.Repositories) *CVsUsecase <span class="cov0" title="0">{
        return &amp;CVsUsecase{
                logger:      logger,
                cvsRepo:     repositories.CVRepository,
                sessionRepo: repositories.SessionApplicantRepository,
        }
}</span>

func (cu *CVsUsecase) GetApplicantCVs(applicantID uint64) ([]*dto.JSONGetApplicantCV, error) <span class="cov0" title="0">{
        fn := "CVsUsecase.GetApplicantCVs"

        CVsModel, err := cu.cvsRepo.GetCVsByApplicantID(applicantID)
        if err != nil </span><span class="cov0" title="0">{
                cu.logger.Errorf("function %s: got err %s", fn, err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">cu.logger.Debugf("function %s: success, got CVs from repository: %d", fn, len(CVsModel))

        CVs := make([]*dto.JSONGetApplicantCV, 0, len(CVsModel))
        for _, CVModel := range CVsModel </span><span class="cov0" title="0">{
                CVs = append(CVs, &amp;dto.JSONGetApplicantCV{
                        ID:                CVModel.ID,
                        ApplicantID:       CVModel.ApplicantID,
                        PositionRu:        CVModel.PositionRu,
                        PositionEn:        CVModel.PositionEn,
                        JobSearchStatus:   CVModel.JobSearchStatusName,
                        WorkingExperience: CVModel.WorkingExperience,
                        CreatedAt:         CVModel.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return CVs, nil</span>
}

func (cu *CVsUsecase) CreateCV(cv *dto.JSONCv, currentUser *dto.SessionUser) (*dto.JSONCv, error) <span class="cov0" title="0">{
        cv.ApplicantID = currentUser.ID
        cv, err := cu.cvsRepo.Create(cv)
        if err != nil </span><span class="cov0" title="0">{
                cu.logger.Errorf("while adding to db got err: %s", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return cv, nil</span>
}

func (cu *CVsUsecase) GetCV(cvID uint64) (*dto.JSONCv, error) <span class="cov0" title="0">{
        cv, err := cu.cvsRepo.GetByID(cvID)
        if err != nil </span><span class="cov0" title="0">{
                cu.logger.Errorf("while getting from db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">return cv, nil</span>
}

func (cu *CVsUsecase) UpdateCV(ID uint64, currentUser *dto.SessionUser, cv *dto.JSONCv) (*dto.JSONCv, error) <span class="cov0" title="0">{
        oldCv, err := cu.cvsRepo.GetByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                cu.logger.Errorf("while getting from db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">if currentUser.ID != oldCv.ApplicantID </span><span class="cov0" title="0">{
                cu.logger.Errorf("not an owner tried to update CV, got %d expected %d", currentUser.ID, cv.ApplicantID)
                return nil, fmt.Errorf(dto.MsgAccessDenied)
        }</span>
        <span class="cov0" title="0">cv.ApplicantID = oldCv.ApplicantID
        newCV, err := cu.cvsRepo.Update(ID, cv)

        if err != nil </span><span class="cov0" title="0">{
                cu.logger.Errorf("while updating in db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">return newCV, nil</span>
}

func (cu *CVsUsecase) DeleteCV(cvID uint64, currentUser *dto.SessionUser) error <span class="cov0" title="0">{
        cv, err := cu.cvsRepo.GetByID(cvID)
        if err != nil </span><span class="cov0" title="0">{
                cu.logger.Errorf("while getting from db got err %s", err)
                return fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">if cv.ApplicantID != currentUser.ID </span><span class="cov0" title="0">{
                cu.logger.Errorf("not an owner tried to delete CV, got %d expected %d", currentUser.ID, cv.ApplicantID)
                return fmt.Errorf(dto.MsgAccessDenied)
        }</span>
        <span class="cov0" title="0">err = cu.cvsRepo.Delete(cvID)
        if err != nil </span><span class="cov0" title="0">{
                cu.logger.Errorf("while deleting from db got err %s", err)
                return fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package delivery is a handlers layer of employer
package delivery

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/repository"
        employerUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/usecase"
        sessionRepo "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils"

        "github.com/sirupsen/logrus"
)

// CreateEmployerHandler creates employers in db
// CreateEmployer godoc
// @Summary     Creates a new user as a employer
// @Description -
// @Tags        Registration
// @Accept      json
// @Produce     json
// @Success     200      {object}       dto.JSONResponse{statusCode=200,body=dto.JSONUserBody, error=""} "OK"
// @Failure     400      {object}       nil
// @Router      /registration/employer/ [post]
func CreateEmployerHandler(repo repository.EmployerRepository, repoEmployerSession sessionRepo.SessionRepository, backendAddress string) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer r.Body.Close()

                funcName := "CreateEmployerHandler"
                logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("function %s: can't get logger from context\n", funcName)
                        return
                }</span>

                <span class="cov0" title="0">decoder := json.NewDecoder(r.Body)

                newUserInput := new(dto.EmployerInput)
                err := decoder.Decode(newUserInput)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error while unmarshall employer  JSON: %s", err)
                        middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      dto.MsgInvalidJSON,
                        })
                        return
                }</span>

                <span class="cov0" title="0">if err := employerUsecase.CreateEmployerInputCheck(newUserInput); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("employer invalid fields")
                        middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">logger.Debugf("function %s: employer input check passed", funcName)

                user, sessionID, err := employerUsecase.CreateEmployer(repo, repoEmployerSession, newUserInput)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("function %s: err - %s", funcName, err)
                        middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                                HTTPStatus: http.StatusInternalServerError,
                                Error:      err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">logger.Debug("Cookie send")
                cookie := utils.MakeAuthCookie(sessionID, backendAddress)
                http.SetCookie(w, cookie)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("function %s: got err while adding applicant to db %s", funcName, err)
                        middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                                HTTPStatus: http.StatusInternalServerError,
                                Error:      err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">user.UserType = dto.UserTypeEmployer
                        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                                HTTPStatus: http.StatusOK,
                                Body:       user,
                        })</span>
        })
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package delivery

import (
        "encoding/json"
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/commonerrors"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        employerUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/usecase"
        vacanciesUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/usecase"
        "github.com/sirupsen/logrus"
)

type EmployerProfileHandlers struct {
        logger           *logrus.Logger
        employerUsecase  *employerUsecase.EmployerUsecase
        vacanciesUsecase *vacanciesUsecase.VacanciesUsecase
}

func NewEmployerProfileHandlers(logger *logrus.Logger, usecases *internal.Usecases) (*EmployerProfileHandlers, error) <span class="cov0" title="0">{
        employerUsecase, ok1 := usecases.EmployerUsecase.(*employerUsecase.EmployerUsecase)
        //logger.Debug("err with employerUsecase ", ok1)
        vacanciesUsecase, ok2 := usecases.VacanciesUsecase.(*vacanciesUsecase.VacanciesUsecase)
        //logger.Debug("err with vacanciesUsecase ", ok2)
        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                return nil, commonerrors.ErrUnableToCast
        }</span>
        <span class="cov0" title="0">return &amp;EmployerProfileHandlers{
                logger:           logger,
                employerUsecase:  employerUsecase,
                vacanciesUsecase: vacanciesUsecase,
        }, nil</span>
}

func (h *EmployerProfileHandlers) EmployerProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.GetEmployerProfileHandler(w, r)</span>
        case http.MethodPut:<span class="cov0" title="0">
                h.UpdateEmployerProfileHandler(w, r)</span>
        default:<span class="cov0" title="0">
                middleware.UniversalMarshal(w, http.StatusMethodNotAllowed, dto.JSONResponse{
                        HTTPStatus: http.StatusMethodNotAllowed,
                        Error:      dto.MsgMethodNotAllowed,
                })</span>
        }
}

func (h *EmployerProfileHandlers) GetEmployerProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "EmployerProfileHandlers.GetEmployerProfileHandler"

        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/employer/profile/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>

        <span class="cov0" title="0">employerID := uint64(ID)
        // dto - JSONGetEmployerProfile
        employerProfile, err := h.employerUsecase.GetEmployerProfile(employerID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debugf("function %s: success, got profile %v", fn, employerProfile)
        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       employerProfile,
        })</span>
}

func (h *EmployerProfileHandlers) UpdateEmployerProfileHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "EmployerProfileHandlers.UpdateEmployerProfileHandler"
        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/employer/profile/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>

        <span class="cov0" title="0">employerID := uint64(ID)

        decoder := json.NewDecoder(r.Body)
        newProfileData := new(dto.JSONUpdateEmployerProfile)
        err = decoder.Decode(newProfileData)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                        HTTPStatus: http.StatusBadRequest,
                        Error:      dto.MsgInvalidJSON,
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debugf("function %s: new profile data JSON parsed: %v", fn, newProfileData)

        err = h.employerUsecase.UpdateEmployerProfile(employerID, newProfileData)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">h.logger.Debugf("function %s: success", fn)</span>
}

func (h *EmployerProfileHandlers) GetEmployerVacanciesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        fn := "EmployerProfileHandlers.GetEmployerVacanciesHandler"

        ID, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/employer/vacancies/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                return
        }</span>

        <span class="cov0" title="0">employerID := uint64(ID)
        vacancies, err := h.vacanciesUsecase.GetVacanciesByEmployerID(employerID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("function %s: got err %s", fn, err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">h.logger.Debugf("function %s: success, got vacancies: %d", fn, len(vacancies))
        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       vacancies,
        })</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/models"
)

// DOES NOT SUPPORT ASYNC

// implementation of repository.Employer interface
// temp in-memory-db
type employerRepo struct {
        lastID uint64
        data   []*models.Employer
}

// DOES NOT SUPPORT ASYNC
// Initialize new repo
// Returns pointer to it
func NewRepo() *employerRepo <span class="cov0" title="0">{
        return &amp;employerRepo{
                lastID: 0,
                data:   make([]*models.Employer, 0, 10),
        }
}</span>

// Creates new employer
// Accepts pointer to employer model
// Returns ID of created employer and error
func (repo *employerRepo) Create(employerInput *dto.EmployerInput) (*models.Employer, error) <span class="cov0" title="0">{
        employer := &amp;models.Employer{
                ID:                 repo.lastID,
                FirstName:          employerInput.FirstName,
                LastName:           employerInput.LastName,
                Position:           employerInput.Position,
                CompanyName:        employerInput.CompanyName,
                CompanyDescription: employerInput.CompanyDescription,
                CompanyWebsite:     employerInput.CompanyWebsite,
                Email:              employerInput.Email,
                PasswordHash:       employerInput.Password,
        }
        repo.lastID++
        repo.data = append(repo.data, employer)

        return employer, nil
}</span>

// GetByID gets employer by ID
// Accepts ID
// Returns pointer to employer and error
// !!!if NOT FOUND DOESN'T return error yet!!!
func (repo *employerRepo) GetByID(id uint64) (*models.Employer, error) <span class="cov0" title="0">{
        if id &gt; repo.lastID </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return repo.data[id], nil</span>
}

func (repo *employerRepo) GetByEmail(email string) (*models.Employer, error) <span class="cov0" title="0">{
        for _, employer := range repo.data </span><span class="cov0" title="0">{
                if employer.Email == email </span><span class="cov0" title="0">{
                        return employer, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, ErrNoUserExist</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "database/sql"
        "errors"
        "fmt"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/models"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
)

// PostgreSQLBoardStorage
// Хранилище досок в PostgreSQL
type PostgreSQLEmployerStorage struct {
        db *sql.DB
}

func NewEmployerStorage(db *sql.DB) *PostgreSQLEmployerStorage <span class="cov0" title="0">{
        return &amp;PostgreSQLEmployerStorage{
                db: db,
        }
}</span>

// GetByID
// находит доску и связанные с ней списки и задания по id
// или возвращает ошибки ...
func (s *PostgreSQLEmployerStorage) GetByID(id uint64) (*models.Employer, error) <span class="cov0" title="0">{
        // funcName := "PostgreSQLemployer.GetById"
        // logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
        // if !ok {
        //         fmt.Printf("function %s: can't get logger from context\n", funcName)
        // }

        //requestID := ctx.Value(dto.RequestIDKey).(uuid.UUID)

        //logger.DebugFmt("Built query\n\t"+boardSql+"\nwith args\n\t"+fmt.Sprintf("%+v", args), requestID.String(), funcName, nodeName)
        row := s.db.QueryRow(`select employer.id, first_name, last_name, city.city_name, position, company.company_name, company_description, company_website, path_to_profile_avatar, contacts, 
        email, password_hash, employer.created_at, employer.updated_at 
        from employer left join city on employer.city_id = city.id left join company on employer.company_name_id = company.id where employer.id = $1`, id)

        var employerWithNull dto.EmployerWithNull
        err := row.Scan(
                &amp;employerWithNull.ID,
                &amp;employerWithNull.FirstName,
                &amp;employerWithNull.LastName,
                &amp;employerWithNull.CityName,
                &amp;employerWithNull.Position,
                &amp;employerWithNull.CompanyName,
                &amp;employerWithNull.CompanyDescription,
                &amp;employerWithNull.CompanyWebsite,
                &amp;employerWithNull.PathToProfileAvatar,
                &amp;employerWithNull.Contacts,
                &amp;employerWithNull.Email,
                &amp;employerWithNull.PasswordHash,
                &amp;employerWithNull.CreatedAt,
                &amp;employerWithNull.UpdatedAt,
        )
        employer := models.Employer{
                ID:                  employerWithNull.ID,
                FirstName:           employerWithNull.FirstName,
                LastName:            employerWithNull.LastName,
                CityName:            employerWithNull.CityName.String,
                Position:            employerWithNull.Position,
                CompanyName:         employerWithNull.CompanyName,
                CompanyDescription:  employerWithNull.CompanyDescription,
                CompanyWebsite:      employerWithNull.CompanyWebsite,
                PathToProfileAvatar: employerWithNull.PathToProfileAvatar,
                Contacts:            employerWithNull.Contacts.String,
                Email:               employerWithNull.Email,
                PasswordHash:        employerWithNull.PasswordHash,
                CreatedAt:           employerWithNull.CreatedAt,
                UpdatedAt:           employerWithNull.UpdatedAt,
        }

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //logger.DebugFmt(fmt.Sprintf("%+v", board), requestID.String(), funcName, nodeName)

        <span class="cov0" title="0">return &amp;employer, nil</span>
}

func (s *PostgreSQLEmployerStorage) GetByEmail(email string) (*models.Employer, error) <span class="cov0" title="0">{
        //log.Println("Looking for user with login", login.Value)

        //log.Println("Built query:", sql, "\nwith args:", args)

        row := s.db.QueryRow(`select employer.id, first_name, last_name, city.city_name, position, company.company_name, company_description, company_website, path_to_profile_avatar, contacts, 
        email, password_hash, employer.created_at, employer.updated_at 
        from employer left join city on employer.city_id = city.id left join company on employer.company_name_id = company.id where employer.email = $1`, email)

        var employerWithNull dto.EmployerWithNull
        err := row.Scan(
                &amp;employerWithNull.ID,
                &amp;employerWithNull.FirstName,
                &amp;employerWithNull.LastName,
                &amp;employerWithNull.CityName,
                &amp;employerWithNull.Position,
                &amp;employerWithNull.CompanyName,
                &amp;employerWithNull.CompanyDescription,
                &amp;employerWithNull.CompanyWebsite,
                &amp;employerWithNull.PathToProfileAvatar,
                &amp;employerWithNull.Contacts,
                &amp;employerWithNull.Email,
                &amp;employerWithNull.PasswordHash,
                &amp;employerWithNull.CreatedAt,
                &amp;employerWithNull.UpdatedAt,
        )
        employer := models.Employer{
                ID:                  employerWithNull.ID,
                FirstName:           employerWithNull.FirstName,
                LastName:            employerWithNull.LastName,
                CityName:            employerWithNull.CityName.String,
                Position:            employerWithNull.Position,
                CompanyName:         employerWithNull.CompanyName,
                CompanyDescription:  employerWithNull.CompanyDescription,
                CompanyWebsite:      employerWithNull.CompanyWebsite,
                PathToProfileAvatar: employerWithNull.PathToProfileAvatar,
                Contacts:            employerWithNull.Contacts.String,
                Email:               employerWithNull.Email,
                PasswordHash:        employerWithNull.PasswordHash,
                CreatedAt:           employerWithNull.CreatedAt,
                UpdatedAt:           employerWithNull.UpdatedAt,
        }
        //log.Println(user)
        //log.Println(err)
        return &amp;employer, err
}</span>

func (s *PostgreSQLEmployerStorage) Create(employerInput *dto.EmployerInput) (*models.Employer, error) <span class="cov0" title="0">{

        var CompanyNameId int
        row := s.db.QueryRow(`select id from company where company_name = $1`, employerInput.CompanyName)
        if err := row.Scan(&amp;CompanyNameId); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        row = s.db.QueryRow(`insert into company (company_name) VALUES ($1) returning id`, employerInput.CompanyName)
                        err = row.Scan(&amp;CompanyNameId)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }

        <span class="cov0" title="0">_, err := s.db.Exec(`insert into employer (first_name, last_name, position, company_name_id, company_description, company_website, email, password_hash)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
                employerInput.FirstName, employerInput.LastName, employerInput.Position, CompanyNameId, employerInput.CompanyDescription,
                employerInput.CompanyWebsite, employerInput.Email, employerInput.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">employer, err := s.GetByEmail(employerInput.Email)
        fmt.Println(err)
        if !errors.Is(err, nil) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return employer, err</span>
}

func (s *PostgreSQLEmployerStorage) Update(ID uint64, newEmployerData *dto.JSONUpdateEmployerProfile) error <span class="cov0" title="0">{

        var CityId int
        row := s.db.QueryRow(`select id from city where city_name=$1`, newEmployerData.City)
        if err := row.Scan(&amp;CityId); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        row = s.db.QueryRow(`insert into city (city_name) VALUES ($1) returning id`, newEmployerData.City)
                        err = row.Scan(&amp;CityId)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
        <span class="cov0" title="0">_, err := s.db.Exec(`update employer
                set first_name = $1, last_name = $2, city_id = $3,
                contacts = $4 where id=$5`,
                newEmployerData.FirstName, newEmployerData.LastName, CityId, newEmployerData.Contacts, ID)
        return err</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package usecase

import (
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        employerRepository "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/repository"
        "github.com/sirupsen/logrus"
)

type IEmployerUsecase interface {
        GetEmployerProfile(employerID uint64) (*dto.JSONGetEmployerProfile, error)
        UpdateEmployerProfile(employerID uint64, employerProfile *dto.JSONUpdateEmployerProfile) error
}

type EmployerUsecase struct {
        logger             *logrus.Logger
        employerRepository employerRepository.EmployerRepository
}

func NewEmployerUsecase(logger *logrus.Logger, repositories *internal.Repositories) *EmployerUsecase <span class="cov0" title="0">{
        employerRepository, ok := repositories.EmployerRepository.(employerRepository.EmployerRepository)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;EmployerUsecase{
                logger:             logger,
                employerRepository: employerRepository,
        }</span>
}

func (eu *EmployerUsecase) GetEmployerProfile(employerID uint64) (*dto.JSONGetEmployerProfile, error) <span class="cov0" title="0">{
        fn := "EmployerUsecase.GetEmployerProfile"
        employerModel, err := eu.employerRepository.GetByID(employerID)
        if err != nil </span><span class="cov0" title="0">{
                eu.logger.Debugf("function: %s; unable to get employer profile: %s", fn, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">eu.logger.Debugf("function: %s; got employer profile: %v", fn, employerModel)
        return &amp;dto.JSONGetEmployerProfile{
                ID:                 employerModel.ID,
                FirstName:          employerModel.FirstName,
                LastName:           employerModel.LastName,
                City:               employerModel.CityName,
                Position:           employerModel.Position,
                Company:            employerModel.CompanyName,
                CompanyDescription: employerModel.CompanyDescription,
                CompanyWebsite:     employerModel.CompanyWebsite,
                Contacts:           employerModel.Contacts,
        }, nil</span>
}

func (eu *EmployerUsecase) UpdateEmployerProfile(employerID uint64, employerProfile *dto.JSONUpdateEmployerProfile) error <span class="cov0" title="0">{
        fn := "EmployerUsecase.UpdateEmployerProfile"
        err := eu.employerRepository.Update(employerID, employerProfile)
        if err != nil </span><span class="cov0" title="0">{
                eu.logger.Errorf("function: %s; unable to update employer profile: %s", fn, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package usecase contains usecase for employer
package usecase

import (
        "fmt"
        "strings"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/repository"
        repoSession "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils"
)

// CreateEmployerInputCheck accepts registartion form and checks it
func CreateEmployerInputCheck(form *dto.EmployerInput) error <span class="cov0" title="0">{
        if len(form.FirstName) &gt; 50 || len(form.LastName) &gt; 50 || len(form.Position) &gt; 50 ||
                len(form.CompanyName) &gt; 50 || strings.Index(form.Email, "@") &lt; 0 || len(form.Password) &gt; 50 </span><span class="cov0" title="0">{
                return fmt.Errorf("employer's fields aren't valid %s %s %s %s %s",
                        form.FirstName,
                        form.LastName,
                        form.Position,
                        form.CompanyName,
                        form.Email,
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateEmployer accepts employer repository and validated form and creates new employer

func CreateEmployer(repo repository.EmployerRepository, sessionRepoEmployer repoSession.SessionRepository, form *dto.EmployerInput) (*dto.EmployerOutput, string, error) <span class="cov0" title="0">{
        employer, err := repo.GetByEmail(form.Email)
        fmt.Println("!-------------", employer, err)
        // if err.Error() != "sql: no rows in result set" {
        //         return nil, "", fmt.Errorf(dto.MsgUserAlreadyExists)
        // }
        if err.Error() != "sql: no rows in result set" </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">form.Password = utils.HashPassword(form.Password)
        user, err := repo.Create(form)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">sessionID := utils.GenerateSessionToken(utils.TokenLength, dto.UserTypeEmployer)
        sessionRepoEmployer.Create(user.ID, sessionID)
        return &amp;dto.EmployerOutput{
                ID:                  user.ID,
                FirstName:           user.FirstName,
                LastName:            user.LastName,
                CityName:            user.CityName,
                Position:            user.Position,
                CompanyName:         user.CompanyName,
                CompanyDescription:  user.CompanyDescription,
                CompanyWebsite:      user.CompanyWebsite,
                PathToProfileAvatar: user.PathToProfileAvatar,
                Contacts:            user.Contacts,
                Email:               user.Email,
                PasswordHash:        user.PasswordHash,
                CreatedAt:           user.CreatedAt,
                UpdatedAt:           user.UpdatedAt,
        }, sessionID, err</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/models"
)

type PostgreSQLPortfolioStorage struct {
        db *sql.DB
}

func NewPortfolioStorage(db *sql.DB) *PostgreSQLPortfolioStorage <span class="cov0" title="0">{
        return &amp;PostgreSQLPortfolioStorage{
                db: db,
        }
}</span>

func (s *PostgreSQLPortfolioStorage) GetPortfoliosByApplicantID(applicantID uint64) ([]*models.Portfolio, error) <span class="cov0" title="0">{
        //row := s.db.QueryRow(`select id, applicant_id, portfolio_name, created_at, updated_at  from portfolio where portfolio.applicant_id = $1`, applicantID)

        portfolios := make([]*models.Portfolio, 0)

        rows, err := s.db.Query(`select id, applicant_id, portfolio_name, created_at, updated_at  from portfolio where portfolio.applicant_id = $1`, applicantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var portfolio models.Portfolio
                if err := rows.Scan(&amp;portfolio.ID, &amp;portfolio.ApplicantID, &amp;portfolio.Name, &amp;portfolio.CreatedAt, &amp;portfolio.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">portfolios = append(portfolios, &amp;portfolio)
                fmt.Println(portfolio)</span>
        }

        <span class="cov0" title="0">return portfolios, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package usecase

import (
        "fmt"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/portfolio/repository"
        "github.com/sirupsen/logrus"
)

type IPortfolioUsecase interface {
        GetApplicantPortfolios(applicantID uint64) ([]*dto.JSONGetApplicantPortfolio, error)
}

type PortfolioUsecase struct {
        logger        *logrus.Logger
        portfolioRepo repository.IPortfolioRepository
}

func NewPortfolioUsecase(logger *logrus.Logger, repositories *internal.Repositories) *PortfolioUsecase <span class="cov0" title="0">{
        PortfolioRepository, ok := repositories.PortfolioRepository.(repository.IPortfolioRepository)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PortfolioUsecase{
                logger:        logger,
                portfolioRepo: PortfolioRepository,
        }</span>
}

func (pu *PortfolioUsecase) GetApplicantPortfolios(applicantID uint64) ([]*dto.JSONGetApplicantPortfolio, error) <span class="cov0" title="0">{
        fn := "PortfolioUsecase.GetApplicantPortfolio"

        pu.logger.Debugf("function: %s; applicant id: %d. Trying to get applicant portfolio", fn, applicantID)
        portfoliosModel, err := pu.portfolioRepo.GetPortfoliosByApplicantID(applicantID)
        if err != nil </span><span class="cov0" title="0">{
                pu.logger.Errorf("function: %s; got err: %s", fn, err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>

        <span class="cov0" title="0">pu.logger.Debugf("function: %s; successfully got applicant portfolios: %d", fn, len(portfoliosModel))
        portfolio := make([]*dto.JSONGetApplicantPortfolio, 0, len(portfoliosModel))
        for _, portfolioModel := range portfoliosModel </span><span class="cov0" title="0">{
                portfolio = append(portfolio, &amp;dto.JSONGetApplicantPortfolio{
                        ID:          portfolioModel.ID,
                        ApplicantID: portfolioModel.ApplicantID,
                        Name:        portfolioModel.Name,
                        CreatedAt:   portfolioModel.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return portfolio, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package delivery is a handlers layer of session
package delivery

import (
        "encoding/json"
        "fmt"
        "net/http"

        "time"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware"
        applicantRepo "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        employerRepo "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils"

        sessionRepo "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/repository"
        sessionUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session/usecase"
        "github.com/sirupsen/logrus"
)

// AuthorizedHandler checks authorization of user
// Authorized godoc
// @Summary     Checks user's authorization
// @Description Gets cookie from user and checks authentication
// @Tags        AuthStatus
// @Param       session_id header string true "Session ID (Cookie)"
// @Success     200
// @Failure     401
// @Router      /authorized [post]
func AuthorizedHandler(repoApplicantSession sessionRepo.SessionRepository,
        repoEmployerSession sessionRepo.SessionRepository,
        repoApplicant applicantRepo.IApplicantRepository,
        repoEmployer employerRepo.EmployerRepository) http.Handler <span class="cov0" title="0">{ // just do it!
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer r.Body.Close()

                funcName := "AuthorizedHandler"

                logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("function %s: can't get logger from context\n", funcName)
                }</span>

                <span class="cov0" title="0">session, err := r.Cookie("session_id1")

                if err != nil </span><span class="cov0" title="0">{
                        logger.Debugf("function: %s; problems with reading cookie", funcName)
                        middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                                HTTPStatus: http.StatusUnauthorized,
                                Error:      "client doesn't have a cookie",
                        })
                        return
                }</span>

                <span class="cov0" title="0">userType, err := utils.CheckToken(session.Value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("wrong cookie")
                        middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      "wrong cookie",
                        })
                        return
                }</span>
                <span class="cov0" title="0">newUserInput := &amp;dto.JSONLogoutForm{UserType: userType}

                id, err := sessionUsecase.CheckAuthorization(newUserInput, session, repoApplicantSession, repoEmployerSession)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("authorization error")
                        middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                                HTTPStatus: http.StatusUnauthorized,
                                Error:      err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">logger.WithField("session_id", session.Value).Debug("got session id")
                logger.Debugf("Just authorized user! UserType: %s; ID %d", newUserInput.UserType, id)

                if newUserInput.UserType == dto.UserTypeApplicant </span><span class="cov0" title="0">{
                        userout, err := sessionUsecase.GetApplicantByID(repoApplicant, id)
                        userout.UserType = dto.UserTypeApplicant
                        if err == nil </span><span class="cov0" title="0">{
                                middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                                        HTTPStatus: http.StatusOK,
                                        Body:       userout,
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> if newUserInput.UserType == dto.UserTypeEmployer </span><span class="cov0" title="0">{
                        userout, err := sessionUsecase.GetEmployerByID(repoEmployer, id)
                        userout.UserType = dto.UserTypeEmployer
                        if err == nil </span><span class="cov0" title="0">{
                                middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                                        HTTPStatus: http.StatusOK,
                                        Body:       userout,
                                })
                                return
                        }</span>
                }
                <span class="cov0" title="0">logger.Errorf("function %s: login got strange type - %s", funcName, newUserInput.UserType)
                middleware.UniversalMarshal(
                        w,
                        http.StatusBadRequest,
                        dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      "function " + funcName + ": login got strange type - " + newUserInput.UserType,
                        },
                )</span>
        })
}

// LoginHandler set cookies for users after login
// Login godoc
// @Summary     Realises authentication
// @Description -
// @Tags        Login
// @Accept      json
// @Param       email    body string  true "User's email"
// @Param       password body string  true "User's password"
// @Success     200 {object} map[string]interface{}
// @Failure     400 {object} map[string]interface{}
// @Failure     401 {object} map[string]interface{}
// @Router      /login/ [post]
func LoginHandler(
        repoApplicantSession sessionRepo.SessionRepository,
        repoEmployerSession sessionRepo.SessionRepository,
        repoApplicant applicantRepo.IApplicantRepository,
        repoEmployer employerRepo.EmployerRepository,
        backendAddress string,
) http.Handler <span class="cov0" title="0">{ // just do it!
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer r.Body.Close()
                funcName := "LoginHandler"
                logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("function %s: can't get logger from context\n", funcName)
                }</span>

                <span class="cov0" title="0">decoder := json.NewDecoder(r.Body)

                newUserInput := new(dto.JSONLoginForm)
                err := decoder.Decode(newUserInput)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("can't unmarshal JSON")
                        middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      "can't unmarshal JSON",
                        })
                        return
                }</span>

                <span class="cov0" title="0">user, err := sessionUsecase.LoginValidate(newUserInput, repoApplicant, repoEmployer)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("function %s: login validation got %s", funcName, err.Error())
                        middleware.UniversalMarshal(
                                w,
                                http.StatusBadRequest,
                                dto.JSONResponse{
                                        HTTPStatus: http.StatusBadRequest,
                                        Error:      err.Error(),
                                },
                        )
                        return
                }</span>
                <span class="cov0" title="0">logger.Debugf("function %s: got user with id %d", funcName, user.ID)

                sessionID, err := sessionUsecase.AddSession(repoApplicantSession, repoEmployerSession, user)

                // TODO: remake error comparison
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debugf("function %s: session adding got %s", funcName, err.Error())
                        middleware.UniversalMarshal(
                                w,
                                http.StatusBadRequest,
                                dto.JSONResponse{
                                        HTTPStatus: http.StatusBadRequest,
                                        Error:      err.Error(),
                                },
                        )
                        return
                }</span>
                <span class="cov0" title="0">logger.Debugf("function %s: session added successfully", funcName)

                logger.Debug("Cookie send")
                cookie := utils.MakeAuthCookie(sessionID, backendAddress)
                http.SetCookie(w, cookie)

                if newUserInput.UserType == dto.UserTypeApplicant </span><span class="cov0" title="0">{
                        userout, err := sessionUsecase.GetApplicantByEmail(repoApplicant, newUserInput.Email)
                        userout.UserType = dto.UserTypeApplicant
                        if err == nil </span><span class="cov0" title="0">{
                                middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                                        HTTPStatus: http.StatusOK,
                                        Body:       userout,
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> if newUserInput.UserType == dto.UserTypeEmployer </span><span class="cov0" title="0">{
                        userout, err := sessionUsecase.GetEmployerByEmail(repoEmployer, newUserInput.Email)
                        userout.UserType = dto.UserTypeEmployer
                        if err == nil </span><span class="cov0" title="0">{
                                middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                                        HTTPStatus: http.StatusOK,
                                        Body:       userout,
                                })
                                return
                        }</span>
                }
                <span class="cov0" title="0">logger.Errorf("function %s: login got strange type - %s", funcName, newUserInput.UserType)
                middleware.UniversalMarshal(
                        w,
                        http.StatusBadRequest,
                        dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      "function " + funcName + ": login got strange type - " + newUserInput.UserType,
                        },
                )</span>

        })
}

// LogoutHandler deletes cookies when user want to logout
// Logout godoc
// @Summary     Realises deauthentication
// @Description -
// @Tags        Logout
// @Param       session_id header string true "Session ID (Cookie)"
// @Success     200
// @Failure     400
// @Failure     401
// @Router      /logout/ [post]
func LogoutHandler(repoApplicantSession sessionRepo.SessionRepository,
        repoEmployerSession sessionRepo.SessionRepository,
        repoApplicant applicantRepo.IApplicantRepository,
        repoEmployer employerRepo.EmployerRepository) http.Handler <span class="cov0" title="0">{ // just do it!
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer r.Body.Close()
                funcName := "LogoutHandler"
                logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("function %s: can't get logger from context\n", funcName)
                }</span>
                <span class="cov0" title="0">session, err := r.Cookie("session_id1")
                if err == http.ErrNoCookie </span><span class="cov0" title="0">{
                        logger.Errorf("client doesn't have a cookie")
                        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                                HTTPStatus: http.StatusOK,
                                Error:      "client doesn't have a cookie",
                        })
                        return
                }</span>

                <span class="cov0" title="0">userType, err := utils.CheckToken(session.Value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("wrong cookie")
                        middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      "wrong cookie",
                        })
                        return
                }</span>
                <span class="cov0" title="0">newUserInput := &amp;dto.JSONLogoutForm{UserType: userType}

                sessionID := session.Value
                id, err := sessionUsecase.LogoutValidate(newUserInput, sessionID, repoApplicantSession, repoEmployerSession)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("no user with this session")
                        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                                HTTPStatus: http.StatusOK,
                                Error:      "no user with this session",
                        })
                        return
                }</span>

                <span class="cov0" title="0">session.Expires = time.Now().AddDate(0, 0, -1)
                http.SetCookie(w, session)

                if newUserInput.UserType == dto.UserTypeApplicant </span><span class="cov0" title="0">{
                        userout, err := sessionUsecase.GetApplicantByID(repoApplicant, id)
                        userout.UserType = dto.UserTypeApplicant
                        if err == nil </span><span class="cov0" title="0">{
                                middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                                        HTTPStatus: http.StatusOK,
                                        Body:       userout,
                                })
                                return
                        }</span>
                } else<span class="cov0" title="0"> if newUserInput.UserType == dto.UserTypeEmployer </span><span class="cov0" title="0">{
                        userout, err := sessionUsecase.GetEmployerByID(repoEmployer, id)
                        userout.UserType = dto.UserTypeApplicant
                        if err == nil </span><span class="cov0" title="0">{
                                middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                                        HTTPStatus: http.StatusOK,
                                        Body:       userout,
                                })
                                return
                        }</span>
                }
                <span class="cov0" title="0">logger.Errorf("function %s: login got strange type - %s", funcName, newUserInput.UserType)
                middleware.UniversalMarshal(
                        w,
                        http.StatusBadRequest,
                        dto.JSONResponse{
                                HTTPStatus: http.StatusBadRequest,
                                Error:      "function " + funcName + ": login got strange type - " + newUserInput.UserType,
                        },
                )</span>
        })
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package repository is a repository layer of session
package repository

import (
        "time"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/models"
)

// SessionApplicantRepo is a in-memory implementation for applicant session
type SessionApplicantRepo struct {
        lastID   uint64
        sessions map[string]*models.SessionApplicant
}

// SessionEmployerRepo is a in-memory implementation for employer session
type SessionEmployerRepo struct {
        lastID   uint64
        sessions map[string]*models.SessionEmployer
}

// NewRepo returns new in-memory repository for sessions
func NewRepo() (*SessionApplicantRepo, *SessionEmployerRepo) <span class="cov0" title="0">{
        return &amp;SessionApplicantRepo{
                        lastID:   1,
                        sessions: make(map[string]*models.SessionApplicant),
                }, &amp;SessionEmployerRepo{
                        lastID:   1,
                        sessions: make(map[string]*models.SessionEmployer),
                }
}</span>

// Add adds new applicantsession.
// Accepts applicant's id and session's id.
// Returns error if session already exists or nil in case of success
func (sa *SessionApplicantRepo) Create(userId uint64, sessionID string) error <span class="cov0" title="0">{
        if _, ok := sa.sessions[sessionID]; ok </span><span class="cov0" title="0">{
                return ErrSessionAlreadyExists
        }</span>
        <span class="cov0" title="0">sa.sessions[sessionID] = &amp;models.SessionApplicant{
                ID:          sa.lastID,
                ApplicantID: userId,
                CookieToken: sessionID,
                CreatedAt:   time.Now().String(),
                UpdatedAt:   time.Now().String(),
        }
        sa.lastID++
        return nil</span>
}

func (sa *SessionApplicantRepo) GetUserIdBySession(sessionId string) (uint64, error) <span class="cov0" title="0">{
        if session, ok := sa.sessions[sessionId]; ok </span><span class="cov0" title="0">{
                return session.ApplicantID, nil
        }</span>
        <span class="cov0" title="0">return 0, ErrSessionNotFound</span>
}

func (sa *SessionApplicantRepo) Delete(sessionId string) error <span class="cov0" title="0">{
        delete(sa.sessions, sessionId)
        return nil
}</span>

func (se *SessionEmployerRepo) Create(userId uint64, sessionID string) error <span class="cov0" title="0">{
        if _, ok := se.sessions[sessionID]; ok </span><span class="cov0" title="0">{
                return ErrSessionAlreadyExists
        }</span>
        <span class="cov0" title="0">se.sessions[sessionID] = &amp;models.SessionEmployer{
                ID:          se.lastID,
                EmployerID:  userId,
                CookieToken: sessionID,
                CreatedAt:   time.Now().String(),
                UpdatedAt:   time.Now().String(),
        }
        se.lastID++
        return nil</span>
}

func (se *SessionEmployerRepo) GetUserIdBySession(sessionId string) (uint64, error) <span class="cov0" title="0">{
        if session, ok := se.sessions[sessionId]; ok </span><span class="cov0" title="0">{
                return session.EmployerID, nil
        }</span>
        <span class="cov0" title="0">return 0, ErrSessionNotFound</span>
}

func (se *SessionEmployerRepo) Delete(sessionID string) error <span class="cov0" title="0">{
        delete(se.sessions, sessionID)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "database/sql"
        "fmt"
)

// PostgreSQLBoardStorage
// Хранилище досок в PostgreSQL
type PostgreSQLEmployerSession struct {
        db *sql.DB
}

type PostgreSQLApplicantSession struct {
        db *sql.DB
}

func NewSessionStorage(db *sql.DB) (*PostgreSQLApplicantSession, *PostgreSQLEmployerSession) <span class="cov0" title="0">{
        return &amp;PostgreSQLApplicantSession{
                        db: db,
                }, &amp;PostgreSQLEmployerSession{
                        db: db,
                }
}</span>
func (s *PostgreSQLEmployerSession) GetUserIdBySession(sessionId string) (uint64, error) <span class="cov0" title="0">{
        row := s.db.QueryRow(`select employer_id from employer_session  where session_token = $1`, sessionId)
        var id uint64
        err := row.Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return id, err</span>
}
func (s *PostgreSQLApplicantSession) GetUserIdBySession(sessionId string) (uint64, error) <span class="cov0" title="0">{
        fmt.Println("1")
        row := s.db.QueryRow(`select applicant_id from applicant_session  where session_token = $1`, sessionId)
        var id uint64
        err := row.Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return id, err</span>
}

func (s *PostgreSQLEmployerSession) Create(userId uint64, sessionID string) error <span class="cov0" title="0">{
        _, err := s.db.Exec(`insert into employer_session (employer_id, session_token) VALUES ($1, $2)`, userId, sessionID)
        return err
}</span>
func (s *PostgreSQLApplicantSession) Create(userId uint64, sessionID string) error <span class="cov0" title="0">{
        _, err := s.db.Exec(`insert into applicant_session (applicant_id, session_token) VALUES ($1, $2)`, userId, sessionID)
        return err
}</span>

func (s *PostgreSQLEmployerSession) Delete(sessionId string) error <span class="cov0" title="0">{
        _, err := s.db.Exec(`delete from employer_session where session_token = $1`, sessionId)
        return err
}</span>
func (s *PostgreSQLApplicantSession) Delete(sessionId string) error <span class="cov0" title="0">{
        _, err := s.db.Exec(`delete from applicant_session where session_token = $1`, sessionId)
        return err
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package usecase contains usecase for session
package usecase

import (
        "fmt"
        "net/http"

        applicantRepo "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/applicant/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        employerRepo "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/employer/repository"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/models"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/utils"
)

var ErrEmptyCookie = fmt.Errorf("client have an empty cookie")

func CheckAuthorization(newUserInput *dto.JSONLogoutForm, session *http.Cookie, sessionRepoApplicant session.ISessionRepository, sessionRepoEmployer session.ISessionRepository) (uint64, error) <span class="cov0" title="0">{
        if session == nil || session.Value == "" </span><span class="cov0" title="0">{
                return 0, ErrEmptyCookie
        }</span>
        <span class="cov0" title="0">sessionID := session.Value
        if newUserInput.UserType == dto.UserTypeApplicant </span><span class="cov0" title="0">{
                id, err := sessionRepoApplicant.GetUserIdBySession(sessionID)
                return id, err
        }</span> else<span class="cov0" title="0"> if newUserInput.UserType == dto.UserTypeEmployer </span><span class="cov0" title="0">{
                id, err := sessionRepoEmployer.GetUserIdBySession(sessionID)
                return id, err
        }</span>
        <span class="cov0" title="0">return 0, fmt.Errorf(dto.MsgBadUserType)</span>
}

var (
        // ErrWrongPassword means that password is wrong
        ErrWrongPassword = fmt.Errorf("wrong password")
        // ErrNoApplicantWithSuchEmail means that there is no applicant with such email
        ErrNoApplicantWithSuchEmail = fmt.Errorf("there is no applicant with such email")
        // ErrNoEmployerWithSuchEmail means that there is no employer with such email
        ErrNoEmployerWithSuchEmail = fmt.Errorf("there is no employer with such email")
)

// LoginValidate ! TODO: rename function to more accurate meaning
func LoginValidate(newUserInput *dto.JSONLoginForm, repoApplicant applicantRepo.IApplicantRepository, repoEmployer employerRepo.EmployerRepository) (user *dto.UserIDAndType, err error) <span class="cov0" title="0">{
        // TODO: add logging
        if newUserInput.UserType == dto.UserTypeApplicant </span><span class="cov0" title="0">{
                var worker *models.Applicant
                worker, err = repoApplicant.GetByEmail(newUserInput.Email)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(dto.MsgWrongLoginOrPassword)
                }</span>
                <span class="cov0" title="0">if !utils.EqualHashedPasswords(worker.PasswordHash, newUserInput.Password) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(dto.MsgWrongLoginOrPassword)
                }</span>
                <span class="cov0" title="0">user = &amp;dto.UserIDAndType{ID: worker.ID, UserType: dto.UserTypeApplicant}</span>
        } else<span class="cov0" title="0"> if newUserInput.UserType == dto.UserTypeEmployer </span><span class="cov0" title="0">{
                var employer *models.Employer
                employer, err = repoEmployer.GetByEmail(newUserInput.Email)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(dto.MsgWrongLoginOrPassword)
                }</span>
                <span class="cov0" title="0">if !utils.EqualHashedPasswords(employer.PasswordHash, newUserInput.Password) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(dto.MsgWrongLoginOrPassword)
                }</span>
                <span class="cov0" title="0">user = &amp;dto.UserIDAndType{ID: employer.ID, UserType: dto.UserTypeEmployer}</span>
        }
        <span class="cov0" title="0">return user, err</span>
}

// LogoutValidate tries to remove session from db
// TODO: rename function to more accurate meaning
func LogoutValidate(newUserInput *dto.JSONLogoutForm, session string, sessionRepoApplicant, sessionRepoEmployer session.ISessionRepository) (uint64, error) <span class="cov0" title="0">{
        if newUserInput.UserType == dto.UserTypeApplicant </span><span class="cov0" title="0">{
                id, err := sessionRepoApplicant.GetUserIdBySession(session)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf(dto.MsgDataBaseError)
                }</span>
                <span class="cov0" title="0">err = sessionRepoApplicant.Delete(session)
                if err == nil </span><span class="cov0" title="0">{
                        return id, nil
                }</span>
        } else<span class="cov0" title="0"> if newUserInput.UserType == dto.UserTypeEmployer </span><span class="cov0" title="0">{
                id, err := sessionRepoEmployer.GetUserIdBySession(session)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf(dto.MsgDataBaseError)
                }</span>
                <span class="cov0" title="0">err = sessionRepoEmployer.Delete(session)
                if err == nil </span><span class="cov0" title="0">{
                        return id, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, fmt.Errorf(dto.MsgBadUserType)</span>
}

func AddSession(sessionRepoApplicant, sessionRepoEmployer session.ISessionRepository, user *dto.UserIDAndType) (string, error) <span class="cov0" title="0">{
        var sessionID string
        switch user.UserType </span>{
        case dto.UserTypeApplicant:<span class="cov0" title="0">
                sessionID = utils.GenerateSessionToken(utils.TokenLength, dto.UserTypeApplicant)
                if err := sessionRepoApplicant.Create(user.ID, sessionID); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf(dto.MsgDataBaseError)
                }</span>
        case dto.UserTypeEmployer:<span class="cov0" title="0">
                sessionID = utils.GenerateSessionToken(utils.TokenLength, dto.UserTypeEmployer)
                if err := sessionRepoEmployer.Create(user.ID, sessionID); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf(dto.MsgDataBaseError)
                }</span>
        }
        <span class="cov0" title="0">return sessionID, nil</span>
}

func GetApplicantByEmail(repoApplicant applicantRepo.IApplicantRepository, email string) (*dto.ApplicantOutput, error) <span class="cov0" title="0">{
        user, err := repoApplicant.GetByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">return &amp;dto.ApplicantOutput{
                ID:                  user.ID,
                FirstName:           user.FirstName,
                LastName:            user.LastName,
                CityName:            user.CityName,
                BirthDate:           user.BirthDate,
                PathToProfileAvatar: user.PathToProfileAvatar,
                Contacts:            user.Contacts,
                Education:           user.Education,
                Email:               user.Email,
                CreatedAt:           user.CreatedAt,
                UpdatedAt:           user.UpdatedAt,
        }, nil</span>
}

func GetEmployerByEmail(repoEmployer employerRepo.EmployerRepository, email string) (*dto.EmployerOutput, error) <span class="cov0" title="0">{
        user, err := repoEmployer.GetByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">return &amp;dto.EmployerOutput{
                ID:                  user.ID,
                FirstName:           user.FirstName,
                LastName:            user.LastName,
                CityName:            user.CityName,
                Position:            user.Position,
                CompanyName:         user.CompanyName,
                CompanyDescription:  user.CompanyDescription,
                CompanyWebsite:      user.CompanyWebsite,
                PathToProfileAvatar: user.PathToProfileAvatar,
                Contacts:            user.Contacts,
                Email:               user.Email,
                PasswordHash:        user.PasswordHash,
                CreatedAt:           user.CreatedAt,
                UpdatedAt:           user.UpdatedAt,
        }, nil</span>
}

func GetApplicantByID(repoApplicant applicantRepo.IApplicantRepository, id uint64) (*dto.ApplicantOutput, error) <span class="cov0" title="0">{
        user, err := repoApplicant.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">return &amp;dto.ApplicantOutput{
                ID:                  user.ID,
                FirstName:           user.FirstName,
                LastName:            user.LastName,
                CityName:            user.CityName,
                BirthDate:           user.BirthDate,
                PathToProfileAvatar: user.PathToProfileAvatar,
                Contacts:            user.Contacts,
                Education:           user.Education,
                Email:               user.Email,
                CreatedAt:           user.CreatedAt,
                UpdatedAt:           user.UpdatedAt,
        }, nil</span>
}

func GetEmployerByID(repoEmployer employerRepo.EmployerRepository, id uint64) (*dto.EmployerOutput, error) <span class="cov0" title="0">{
        user, err := repoEmployer.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">return &amp;dto.EmployerOutput{
                ID:                  user.ID,
                FirstName:           user.FirstName,
                LastName:            user.LastName,
                CityName:            user.CityName,
                Position:            user.Position,
                CompanyName:         user.CompanyName,
                CompanyDescription:  user.CompanyDescription,
                CompanyWebsite:      user.CompanyWebsite,
                PathToProfileAvatar: user.PathToProfileAvatar,
                Contacts:            user.Contacts,
                Email:               user.Email,
                PasswordHash:        user.PasswordHash,
                CreatedAt:           user.CreatedAt,
                UpdatedAt:           user.UpdatedAt,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package delivery

import (
        "fmt"
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies"

        vacanciesUsecase "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies/usecase"

        "github.com/sirupsen/logrus"
)

const (
        defaultVacanciesOffset = 0
        defaultVacanciesNum    = 10
)

// GetVacanciesHandler returns list of vacancies
// GetVacancies godoc
// @Summary     Gets list of vacancies
// @Description Accepts offset and number of vacancies with id &gt;= offset. Returns vacancies
// @Tags        Vacancies
// @Produce     json
// @Param       offset query int true "offset"
// @Param       num    query int true "num"
// @Success     200
// @Failure     400
// @Failure     405
// @Failure     500
// @Router      /vacancies [get]
func GetVacanciesHandler(repo vacancies.IVacanciesRepository) http.Handler <span class="cov0" title="0">{ //vacanciesTable *inmemorydb.VacanciesHandler
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer r.Body.Close()

                funcName := "vacancies.GetVacanciesHandler"
                logger, ok := r.Context().Value(dto.LoggerContextKey).(*logrus.Logger)
                if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("%s: can't get logger from context\n", funcName)
                        return
                }</span>

                <span class="cov0" title="0">queryParams := r.URL.Query()
                logger.Debugf("function: %s; Query params read: %v", funcName, queryParams)

                offsetStr := queryParams.Get("offset")
                numStr := queryParams.Get("num")
                offset, num, err := vacanciesUsecase.ValidateRequestParams(offsetStr, numStr)

                // at lest one param is incorrect or not presented
                // using default values
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debugf("function: %s; got err: %s - processing with default values", funcName, err)
                        offset = defaultVacanciesOffset
                        num = defaultVacanciesNum
                }</span>

                <span class="cov0" title="0">logger.Debugf("function: %s; going to db for vacancies", funcName)
                // TODO: use usecase
                vacancies, err := repo.GetWithOffset(offset, offset+num)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("function: %s; got err while reading vacancies from db %s", funcName, err)
                        middleware.UniversalMarshal(
                                w,
                                http.StatusInternalServerError,
                                dto.JSONResponse{
                                        HTTPStatus: http.StatusInternalServerError,
                                        Error:      dto.MsgDataBaseError,
                                },
                        )
                        return
                }</span>

                <span class="cov0" title="0">logger.Debugf("function: %s; got vacancies %+v", funcName, vacancies)
                middleware.UniversalMarshal(
                        w,
                        http.StatusOK,
                        dto.JSONResponse{
                                HTTPStatus: http.StatusOK,
                                Body:       vacancies,
                        },
                )</span>
        })
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package delivery

import (
        "encoding/json"
        "net/http"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/middleware"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/session"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies"
        "github.com/sirupsen/logrus"
)

type VacanciesHandlers struct {
        logger               *logrus.Logger
        vacanciesUsecase     vacancies.IVacanciesUsecase
        sessionEmployerRepo  session.ISessionRepository
        sessionApplicantRepo session.ISessionRepository
}

func NewVacanciesHandlers(layers *internal.App) *VacanciesHandlers <span class="cov0" title="0">{
        logger := layers.Logger
        logger.Debug("VacanciesHandlers created")

        return &amp;VacanciesHandlers{
                logger:               logger,
                vacanciesUsecase:     layers.Usecases.VacanciesUsecase,
                sessionEmployerRepo:  layers.Repositories.SessionEmployerRepository,
                sessionApplicantRepo: layers.Repositories.SessionApplicantRepository,
        }
}</span>

func (h *VacanciesHandlers) VacanciesRESTHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debugf("VacanciesHandlers.VacanciesRESTHandler got request: %s", r.URL.Path)
        repository := &amp;internal.Repositories{SessionEmployerRepository: h.sessionEmployerRepo}
        switch r.Method </span>{
        case http.MethodPost:<span class="cov0" title="0">
                handler := middleware.RequireAuthorization(h.createVacancyHandler, repository, dto.UserTypeEmployer)
                handler(w, r)</span>
        case http.MethodGet:<span class="cov0" title="0">
                h.getVacancyHandler(w, r)</span>
        case http.MethodPut:<span class="cov0" title="0">
                handler := middleware.RequireAuthorization(h.updateVacancyHandler, repository, dto.UserTypeEmployer)
                handler(w, r)</span>
        case http.MethodDelete:<span class="cov0" title="0">
                handler := middleware.RequireAuthorization(h.deleteVacancyHandler, repository, dto.UserTypeEmployer)
                handler(w, r)</span>
        default:<span class="cov0" title="0">
                middleware.UniversalMarshal(w, http.StatusMethodNotAllowed, dto.JSONResponse{
                        HTTPStatus: http.StatusMethodNotAllowed,
                        Error:      dto.MsgMethodNotAllowed,
                })</span>
        }
}

func (h *VacanciesHandlers) VacanciesSubscribeRESTHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.logger.Debugf("VacanciesHandlers.VacanciesSubscribeRESTHandler got request: %s", r.URL.Path)
        repository := &amp;internal.Repositories{SessionApplicantRepository: h.sessionApplicantRepo}
        switch r.Method </span>{
        case http.MethodPost:<span class="cov0" title="0">
                handler := middleware.RequireAuthorization(h.subscribeVacancyHandler, repository, dto.UserTypeApplicant)
                handler(w, r)</span>
        case http.MethodGet:<span class="cov0" title="0">
                handler := middleware.RequireAuthorization(h.getVacancySubscriptionHandler, repository, dto.UserTypeApplicant)
                handler(w, r)</span>
        case http.MethodDelete:<span class="cov0" title="0">
                handler := middleware.RequireAuthorization(h.unsubscribeVacancyHandler, repository, dto.UserTypeApplicant)
                handler(w, r)</span>
        default:<span class="cov0" title="0">
                middleware.UniversalMarshal(w, http.StatusMethodNotAllowed, dto.JSONResponse{
                        HTTPStatus: http.StatusMethodNotAllowed,
                        Error:      dto.MsgMethodNotAllowed,
                })</span>
        }
}

func (h *VacanciesHandlers) GetVacancySubscribersHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        repository := &amp;internal.Repositories{SessionEmployerRepository: h.sessionEmployerRepo}
        handler := middleware.RequireAuthorization(h.getVacancySubscribersHandler, repository, dto.UserTypeEmployer)
        handler(w, r)
}</span>

func (h *VacanciesHandlers) createVacancyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        decoder := json.NewDecoder(r.Body)
        newVacancy := new(dto.JSONVacancy)

        err := decoder.Decode(newVacancy)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("unable to unmarshal JSON: %s", err)
                middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                        HTTPStatus: http.StatusBadRequest,
                        Error:      dto.MsgInvalidJSON,
                })
                return
        }</span>
        

        <span class="cov0" title="0">currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error(dto.MsgUnableToGetUserFromContext)
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>

        <span class="cov0" title="0">wroteVacancy, err := h.vacanciesUsecase.CreateVacancy(newVacancy, currentUser)
        if err != nil </span><span class="cov0" title="0">{
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       wroteVacancy,
        })</span>
}

func (h *VacanciesHandlers) getVacancyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        slug, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/vacancy/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while cutting slug got: %s", err)
                return
        }</span>

        <span class="cov0" title="0">vacancyID := uint64(slug)

        vacancy, err := h.vacanciesUsecase.GetVacancy(vacancyID)
        if err != nil </span><span class="cov0" title="0">{
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       vacancy,
        })</span>
}

func (h *VacanciesHandlers) updateVacancyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        slug, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/vacancy/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while cutting slug got: %s", err)
                return
        }</span>

        <span class="cov0" title="0">vacancyID := uint64(slug)

        decoder := json.NewDecoder(r.Body)
        updatedVacancy := new(dto.JSONVacancy)
        err = decoder.Decode(updatedVacancy)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("unable to unmarshal JSON: %s", err)
                middleware.UniversalMarshal(w, http.StatusBadRequest, dto.JSONResponse{
                        HTTPStatus: http.StatusBadRequest,
                        Error:      dto.MsgInvalidJSON,
                })
                return
        }</span>

        <span class="cov0" title="0">currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error(dto.MsgUnableToGetUserFromContext)
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>
        <span class="cov0" title="0">wroteVacancy, err := h.vacanciesUsecase.UpdateVacancy(vacancyID, updatedVacancy, currentUser)
        if err != nil </span><span class="cov0" title="0">{
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       wroteVacancy,
        })</span>
}

func (h *VacanciesHandlers) deleteVacancyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        slug, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/vacancy/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while cutting slug got: %s", err)
                return
        }</span>

        <span class="cov0" title="0">vacancyID := uint64(slug)

        currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error(dto.MsgUnableToGetUserFromContext)
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.vacanciesUsecase.DeleteVacancy(vacancyID, currentUser)
        if err != nil </span><span class="cov0" title="0">{
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
        })</span>
}

func (h *VacanciesHandlers) subscribeVacancyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        slug, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/vacancy/subscription/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while cutting slug got: %s", err)
                return
        }</span>

        <span class="cov0" title="0">vacancyID := uint64(slug)

        currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error(dto.MsgUnableToGetUserFromContext)
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.vacanciesUsecase.SubscribeOnVacancy(vacancyID, currentUser)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while subscribing on vacancy got: %s", err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">h.logger.Debugf("user_ID: %d subscribed on vacancy_ID %d", currentUser.ID, vacancyID)

        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
        })</span>
}

func (h *VacanciesHandlers) unsubscribeVacancyHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        slug, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/vacancy/subscription/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while cutting slug got: %s", err)
                return
        }</span>

        <span class="cov0" title="0">vacancyID := uint64(slug)

        currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error(dto.MsgUnableToGetUserFromContext)
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>

        <span class="cov0" title="0">err = h.vacanciesUsecase.UnsubscribeFromVacancy(vacancyID, currentUser)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while unsubscribing from vacancy got: %s", err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>
        <span class="cov0" title="0">h.logger.Debugf("user_ID: %d unsubscribed from vacancy_ID %d", currentUser.ID, vacancyID)

        middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
        })</span>
}

func (h *VacanciesHandlers) getVacancySubscriptionHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        slug, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/vacancy/subscription/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while cutting slug got: %s", err)
                return
        }</span>

        <span class="cov0" title="0">vacancyID := uint64(slug)

        currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error(dto.MsgUnableToGetUserFromContext)
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>

        <span class="cov0" title="0">vacancySubscriptionInfo, err := h.vacanciesUsecase.GetSubscriptionInfo(vacancyID, currentUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while getting subscription status got: %s", err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       vacancySubscriptionInfo,
        })</span>
}

func (h *VacanciesHandlers) getVacancySubscribersHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer r.Body.Close()

        slug, err := middleware.GetIDSlugAtEnd(w, r, "/api/v1/vacancy/subscribers/")
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while cutting slug got: %s", err)
                return
        }</span>

        <span class="cov0" title="0">currentUser, ok := r.Context().Value(dto.UserContextKey).(*dto.SessionUser)
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error(dto.MsgUnableToGetUserFromContext)
                middleware.UniversalMarshal(w, http.StatusUnauthorized, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      dto.MsgUnableToGetUserFromContext,
                })
                return
        }</span>

        <span class="cov0" title="0">vacancyID := uint64(slug)

        subscribers, err := h.vacanciesUsecase.GetVacancySubscribers(vacancyID, currentUser)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Errorf("while getting subscribers got: %s", err)
                middleware.UniversalMarshal(w, http.StatusInternalServerError, dto.JSONResponse{
                        HTTPStatus: http.StatusInternalServerError,
                        Error:      err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">middleware.UniversalMarshal(w, http.StatusOK, dto.JSONResponse{
                HTTPStatus: http.StatusOK,
                Body:       subscribers,
        })</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package repository

import (
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/models"
)

// DOES NOT SUPPORT ASYNC

// implementation of repository.Vacancies interface
// in-memory-db
type vacanciesRepo struct {
        lastID uint64
        data   []*models.Vacancy
}

// Initialize new repo
// Returns pointer to it
func NewRepo() *vacanciesRepo <span class="cov0" title="0">{
        vacancies := &amp;vacanciesRepo{
                lastID: 0,
                data:   make([]*models.Vacancy, 0, 10),
        }
        vacancies.lastID = 25
        for i := uint64(0); i &lt; 25; i += 5 </span><span class="cov0" title="0">{
                vacancies.data = append(vacancies.data, &amp;models.Vacancy{
                        ID:       i,
                        Position: "Продавец консультант",
                        Description: `Ищем продавца на полную ставку в ближайший магазин.
                        Требуются ответственные личности, способные на тяжелую работу. Своевременную оплату гарантируем.`,
                        Salary:     "Не указана",
                        EmployerID: 1,
                        //CreatedAt:  "2024.09.29 16:55:00", // YYYY.MM.DD HH:MM:SS
                        Logo: "img/picture_name1.png",
                })
                vacancies.data = append(vacancies.data, &amp;models.Vacancy{
                        ID:       i + 1,
                        Position: "Продавец",
                        Description: `Ищем продавца на полную ставку в ближайший магазин.
                        Требуются ответственные личности, способные на тяжелую работу. Своевременную оплату гарантируем.`,
                        Salary:     "80 000",
                        EmployerID: 1,
                        //CreatedAt:  "2024.09.29 17:55:00", // YYYY.MM.DD HH:MM:SS
                        Logo: "img/picture_name2.png",
                })
                vacancies.data = append(vacancies.data, &amp;models.Vacancy{
                        ID:       i + 2,
                        Position: "Администратор",
                        Description: `Ищем администратора на полную ставку в ближайший магазин.
                        Требуются ответственные личности, способные на продуктивную работу с людьми. Своевременную оплату гарантируем.`,
                        Salary:     "100 500",
                        EmployerID: 1,
                        //CreatedAt:  "2024.09.29 18:55:00", // YYYY.MM.DD HH:MM:SS
                        Logo: "img/picture_name3.png",
                })
                vacancies.data = append(vacancies.data, &amp;models.Vacancy{
                        ID:       i + 3,
                        Position: "Охранник",
                        Description: `Ищем охранника на полную ставку в ближайший магазин.
                        Требуются ответственные личности, способные на тяжелую посменную работу. Своевременную оплату гарантируем.`,
                        Salary:     "Не указана",
                        EmployerID: 1,
                        //CreatedAt:  "2024.09.29 19:55:00", // YYYY.MM.DD HH:MM:SS
                        Logo: "img/picture_name4.png",
                })
                vacancies.data = append(vacancies.data, &amp;models.Vacancy{
                        ID:       i + 4,
                        Position: "Уборщик помещений",
                        Description: `Ищем уборщика на полную ставку в ближайший магазин.
                        Требуются ответственные личности, способные на тяжелую кропотливую работу. Своевременную оплату гарантируем.`,
                        Salary:     "50 000",
                        EmployerID: 1,
                        //CreatedAt:  "2024.09.29 20:55:00", // YYYY.MM.DD HH:MM:SS
                        Logo: "img/picture_name5.png",
                })
        }</span>
        <span class="cov0" title="0">return vacancies</span>
}

// Add new vacncy into the db
// Accepts pointer to vacancy model
// Returns ID of created vacancy and error
func (repo *vacanciesRepo) Create(vacancy *models.Vacancy) (uint64, error) <span class="cov0" title="0">{
        repo.lastID++
        vacancy.ID = repo.lastID
        repo.data = append(repo.data, vacancy)
        return vacancy.ID, nil
}</span>

// GetSomeVacancies get some num amount of vacancies from db starting from offset.
// Dosn't support case when there aren't at least one element in range [offset, offset + num).
// In this case method way cause PANIC.
func (repo *vacanciesRepo) GetWithOffset(offset uint64, num uint64) ([]*models.Vacancy, error) <span class="cov0" title="0">{
        leftBound := offset
        rightBound := offset + num
        // covering cases when offset is out of slice bounds
        if leftBound &gt; repo.lastID </span><span class="cov0" title="0">{
                rightBound = leftBound
        }</span> else<span class="cov0" title="0"> if rightBound &gt; repo.lastID </span><span class="cov0" title="0">{
                rightBound = repo.lastID
        }</span>
        <span class="cov0" title="0">vacancies := repo.data[leftBound:rightBound]
        return vacancies, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/models"
)

type PostgreSQLVacanciesStorage struct {
        Db *sql.DB
}

func NewVacanciesStorage(Db *sql.DB) *PostgreSQLVacanciesStorage <span class="cov8" title="1">{
        return &amp;PostgreSQLVacanciesStorage{
                Db: Db,
        }
}</span>

func (s *PostgreSQLVacanciesStorage) GetVacanciesByEmployerID(employerID uint64) ([]*dto.JSONVacancy, error) <span class="cov8" title="1">{

        Vacancies := make([]*dto.JSONVacancy, 0)

        rows, err := s.Db.Query(`select vacancy.id, city.city_name, vacancy.position, vacancy_description, salary, employer_id, work_type.work_type_name,
                path_to_company_avatar, vacancy.created_at, vacancy.updated_at, company.company_name from vacancy 
                left join work_type on vacancy.work_type_id=work_type.id left join city on vacancy.city_id=city.id
                left join employer on vacancy.employer_id=employer.id left join company on employer.company_name_id=company.id
                where vacancy.employer_id = $1`, employerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var Vacancy dto.JSONVacancy
                if err := rows.Scan(&amp;Vacancy.ID, &amp;Vacancy.Location, &amp;Vacancy.Position, &amp;Vacancy.Description, &amp;Vacancy.Salary,
                        &amp;Vacancy.EmployerID, &amp;Vacancy.WorkType, &amp;Vacancy.Avatar, &amp;Vacancy.CreatedAt, &amp;Vacancy.UpdatedAt, &amp;Vacancy.CompanyName); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">Vacancies = append(Vacancies, &amp;Vacancy)
                fmt.Println(Vacancy)</span>
        }
        <span class="cov8" title="1">return Vacancies, nil</span>
}

func (s *PostgreSQLVacanciesStorage) GetWithOffset(offset uint64, num uint64) ([]*dto.JSONVacancy, error) <span class="cov8" title="1">{
        Vacancies := make([]*dto.JSONVacancy, 0)

        rows, err := s.Db.Query(`select vacancy.id, city.city_name, vacancy.position, vacancy_description, salary, employer_id, work_type.work_type_name,
                path_to_company_avatar, vacancy.created_at, vacancy.updated_at, company.company_name from vacancy
                left join work_type on vacancy.work_type_id=work_type.id left join city on vacancy.city_id=city.id
                left join employer on vacancy.employer_id=employer.id left join company on employer.company_name_id=company.id
                ORDER BY created_at desc limit $1 offset $2`, num, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var Vacancy dto.JSONVacancy
                if err := rows.Scan(&amp;Vacancy.ID, &amp;Vacancy.Location, &amp;Vacancy.Position, &amp;Vacancy.Description, &amp;Vacancy.Salary, &amp;Vacancy.EmployerID,
                        &amp;Vacancy.WorkType, &amp;Vacancy.Avatar, &amp;Vacancy.CreatedAt, &amp;Vacancy.UpdatedAt, &amp;Vacancy.CompanyName); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">Vacancies = append(Vacancies, &amp;Vacancy)
                fmt.Println(Vacancy)</span>
        }

        <span class="cov8" title="1">return Vacancies, nil</span>
}

func (s *PostgreSQLVacanciesStorage) Create(vacancy *dto.JSONVacancy) (uint64, error) <span class="cov8" title="1">{
        var WorkTypeID int
        row := s.Db.QueryRow(`select id from work_type where work_type_name=$1`, vacancy.WorkType)
        if err := row.Scan(&amp;WorkTypeID); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        row = s.Db.QueryRow(`insert into work_type (work_type_name) VALUES ($1) returning id`, vacancy.WorkType)
                        err = row.Scan(&amp;WorkTypeID)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                default:<span class="cov0" title="0">
                        return 0, err</span>
                }
        }
        <span class="cov8" title="1">var CityID int
        row = s.Db.QueryRow(`select id from city where city_name=$1`, vacancy.Location)
        if err := row.Scan(&amp;CityID); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        row = s.Db.QueryRow(`insert into city (city_name) VALUES ($1) returning id`, vacancy.Location)
                        err = row.Scan(&amp;CityID)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                default:<span class="cov0" title="0">
                        return 0, err</span>
                }
        }
        <span class="cov8" title="1">var VacancyId uint64 = 1
        row = s.Db.QueryRow(`insert into vacancy (position, vacancy_description, salary, employer_id, work_type_id,
                path_to_company_avatar, city_id) VALUES ($1, $2, $3, $4, $5, $6, $7) returning id`, vacancy.Position, vacancy.Description,
                vacancy.Salary, vacancy.EmployerID, WorkTypeID, vacancy.Avatar, CityID)
        err := row.Scan(&amp;VacancyId)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return VacancyId, nil</span>
}

func (s *PostgreSQLVacanciesStorage) GetByID(ID uint64) (*dto.JSONVacancy, error) <span class="cov8" title="1">{

        row := s.Db.QueryRow(`select vacancy.id, city.city_name, vacancy.position, vacancy_description, salary, employer_id, work_type.work_type_name,
                path_to_company_avatar, vacancy.created_at, vacancy.updated_at, company.company_name from vacancy 
                left join work_type on vacancy.work_type_id=work_type.id left join city on vacancy.city_id=city.id
                left join employer on vacancy.employer_id=employer.id left join company on employer.company_name_id=company.id
                where vacancy.id = $1`, ID)
        var oneVacancy dto.JSONVacancy

        err := row.Scan(
                &amp;oneVacancy.ID,
                &amp;oneVacancy.Location,
                &amp;oneVacancy.Position,
                &amp;oneVacancy.Description,
                &amp;oneVacancy.Salary,
                &amp;oneVacancy.EmployerID,
                &amp;oneVacancy.WorkType,
                &amp;oneVacancy.Avatar,
                &amp;oneVacancy.CreatedAt,
                &amp;oneVacancy.UpdatedAt,
                &amp;oneVacancy.CompanyName,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;oneVacancy, err</span>
}

func (s *PostgreSQLVacanciesStorage) Update(ID uint64, updatedVacancy *dto.JSONVacancy) (*dto.JSONVacancy, error) <span class="cov8" title="1">{

        var CityId int
        row := s.Db.QueryRow(`select id from city where city_name=$1`, updatedVacancy.Location)
        if err := row.Scan(&amp;CityId); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        row = s.Db.QueryRow(`insert into city (city_name) VALUES ($1) returning id`, updatedVacancy.Location)
                        err = row.Scan(&amp;CityId)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        <span class="cov8" title="1">var WorkTypeID int
        row = s.Db.QueryRow(`select id from work_type where work_type_name=$1`, updatedVacancy.WorkType)
        if err := row.Scan(&amp;WorkTypeID); err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case sql.ErrNoRows:<span class="cov0" title="0">
                        row = s.Db.QueryRow(`insert into work_type (work_type_name) VALUES ($1) returning id`, updatedVacancy.WorkType)
                        err = row.Scan(&amp;WorkTypeID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, err</span>
                }
        }
        <span class="cov8" title="1">row = s.Db.QueryRow(`update vacancy
                set employer_id = $1, salary = $2, position = $3, city_id = $4, vacancy_description = $5,
                work_type_id = $6, path_to_company_avatar = $7 where id=$8 returning id, position, vacancy_description, 
                salary, employer_id, path_to_company_avatar, created_at, updated_at`,
                updatedVacancy.EmployerID, updatedVacancy.Salary, updatedVacancy.Position,
                CityId, updatedVacancy.Description, WorkTypeID, updatedVacancy.Avatar, ID)

        var oneVacancy dto.JSONVacancy
        err := row.Scan(
                &amp;oneVacancy.ID,
                &amp;oneVacancy.Position,
                &amp;oneVacancy.Description,
                &amp;oneVacancy.Salary,
                &amp;oneVacancy.EmployerID,
                &amp;oneVacancy.Avatar,
                &amp;oneVacancy.CreatedAt,
                &amp;oneVacancy.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">row = s.Db.QueryRow(`select company.company_name from employer left join company on company.id = employer.company_name_id where employer.id=$1`, oneVacancy.EmployerID)
        err = row.Scan(
                &amp;oneVacancy.CompanyName)
        oneVacancy.WorkType = updatedVacancy.WorkType
        oneVacancy.Location = updatedVacancy.Location
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;oneVacancy, err</span>
}

func (s *PostgreSQLVacanciesStorage) Delete(ID uint64) error <span class="cov8" title="1">{
        _, err := s.Db.Exec(`delete from vacancy where id = $1`, ID)
        return err
}</span>

func (s *PostgreSQLVacanciesStorage) Subscribe(ID uint64, applicantID uint64) error <span class="cov8" title="1">{
        fmt.Println(ID, applicantID)
        _, err := s.Db.Exec(`insert into vacancy_subscriber (vacancy_id, applicant_id) VALUES ($1, $2)`, ID, applicantID)
        return err
}</span>

func (s *PostgreSQLVacanciesStorage) GetSubscriptionStatus(ID uint64, applicantID uint64) (bool, error) <span class="cov8" title="1">{
        var rowID uint64
        row := s.Db.QueryRow(`select applicant_id from vacancy_subscriber where applicant_id=$1 and vacancy_id=$2`, applicantID, ID)
        if err := row.Scan(&amp;rowID); err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

func (s *PostgreSQLVacanciesStorage) GetSubscribersCount(ID uint64) (uint64, error) <span class="cov8" title="1">{
        var rowCount uint64
        row := s.Db.QueryRow(`select count(id) from vacancy_subscriber where vacancy_id=$1`, ID)
        if err := row.Scan(&amp;rowCount); err != nil </span><span class="cov0" title="0">{
                return rowCount, err
        }</span>
        <span class="cov8" title="1">return rowCount, nil</span>
}

func (s *PostgreSQLVacanciesStorage) GetSubscribersList(ID uint64) ([]*models.Applicant, error) <span class="cov8" title="1">{
        Applicants := make([]*models.Applicant, 0)

        rows, err := s.Db.Query(`select applicant_id, first_name, last_name, city.city_name, birth_date, path_to_profile_avatar,
                contacts, education, email, password_hash , applicant.created_at, applicant.updated_at
                from vacancy_subscriber        left join applicant on applicant.id = applicant_id
                left join city on city.id = applicant.id where vacancy_subscriber.vacancy_id = $1`, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var applicantWithNull dto.ApplicantWithNull
                if err := rows.Scan(&amp;applicantWithNull.ID, &amp;applicantWithNull.FirstName, &amp;applicantWithNull.LastName, &amp;applicantWithNull.CityName,
                        &amp;applicantWithNull.BirthDate, &amp;applicantWithNull.PathToProfileAvatar, &amp;applicantWithNull.Contacts, &amp;applicantWithNull.Education,
                        &amp;applicantWithNull.Email, &amp;applicantWithNull.PasswordHash, &amp;applicantWithNull.CreatedAt, &amp;applicantWithNull.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">oneApplicant := models.Applicant{
                        ID:                  applicantWithNull.ID,
                        FirstName:           applicantWithNull.FirstName,
                        LastName:            applicantWithNull.LastName,
                        CityName:            applicantWithNull.CityName.String,
                        BirthDate:           applicantWithNull.BirthDate,
                        PathToProfileAvatar: applicantWithNull.PathToProfileAvatar,
                        Contacts:            applicantWithNull.Contacts.String,
                        Education:           applicantWithNull.Education.String,
                        Email:               applicantWithNull.Email,
                        PasswordHash:        applicantWithNull.PasswordHash,
                        CreatedAt:           applicantWithNull.CreatedAt,
                        UpdatedAt:           applicantWithNull.UpdatedAt,
                }

                Applicants = append(Applicants, &amp;oneApplicant)
                fmt.Println(oneApplicant)</span>
        }
        <span class="cov8" title="1">return Applicants, nil</span>
}

func (s *PostgreSQLVacanciesStorage) Unsubscribe(ID uint64, applicantID uint64) error <span class="cov8" title="1">{
        _, err := s.Db.Exec(`delete from vacancy_subscriber where applicant_id=$1 and vacancy_id=$2`, applicantID, ID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package usecase contains usecase for vacancies
package usecase

import (
        "fmt"
        "strconv"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/vacancies"
        "github.com/sirupsen/logrus"
)

var ErrOffsetIsNotANumber = fmt.Errorf("query parameter offset isn't a number")
var ErrNumIsNotANumber = fmt.Errorf("query parameter num isn't a number")

type VacanciesUsecase struct {
        logger              *logrus.Logger
        vacanciesRepository vacancies.IVacanciesRepository
}

func NewVacanciesUsecase(logger *logrus.Logger, repositories *internal.Repositories) *VacanciesUsecase <span class="cov0" title="0">{
        return &amp;VacanciesUsecase{
                logger:              logger,
                vacanciesRepository: repositories.VacanciesRepository,
        }
}</span>

func ValidateRequestParams(offsetStr, numStr string) (uint64, uint64, error) <span class="cov0" title="0">{
        var err error
        offset, err1 := strconv.Atoi(offsetStr)

        if err1 != nil </span><span class="cov0" title="0">{
                offset = 0
                err = ErrOffsetIsNotANumber
        }</span>

        <span class="cov0" title="0">num, err2 := strconv.Atoi(numStr)
        if err2 != nil </span><span class="cov0" title="0">{
                num = 0
                err = ErrNumIsNotANumber // previous err will be overwritten
        }</span>
        <span class="cov0" title="0">return uint64(offset), uint64(num), err</span>
}

func (vu *VacanciesUsecase) GetVacanciesByEmployerID(employerID uint64) ([]*dto.JSONGetEmployerVacancy, error) <span class="cov0" title="0">{
        fn := "VacanciesUsecase.GetVacanciesByEmployerID"
        vacanciesModels, err := vu.vacanciesRepository.GetVacanciesByEmployerID(employerID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("function %s: unable to get vacancies: %s", fn, err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>

        <span class="cov0" title="0">vacancies := make([]*dto.JSONGetEmployerVacancy, 0, len(vacanciesModels))
        for _, vacancyModel := range vacanciesModels </span><span class="cov0" title="0">{
                vacancies = append(vacancies, &amp;dto.JSONGetEmployerVacancy{
                        ID:          vacancyModel.ID,
                        EmployerID:  vacancyModel.EmployerID,
                        Salary:      vacancyModel.Salary,
                        Position:    vacancyModel.Position,
                        Description: vacancyModel.Description,
                        WorkType:    vacancyModel.WorkType,
                        Avatar:      vacancyModel.Avatar,
                        CreatedAt:   vacancyModel.CreatedAt,
                })
        }</span>
        <span class="cov0" title="0">return vacancies, nil</span>
}

func (vu *VacanciesUsecase) CreateVacancy(vacancy *dto.JSONVacancy, currentUser *dto.SessionUser) (*dto.JSONVacancy, error) <span class="cov0" title="0">{
        // TODO: need to validate vacancy &amp;&amp; currentUser is not nil

        vu.logger.WithFields(logrus.Fields{"employer_id": currentUser.ID, "user_type": currentUser.UserType}).Debug("got creation request")
        vacancy.EmployerID = currentUser.ID
        createdVacancyID, err := vu.vacanciesRepository.Create(vacancy)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while creating in db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">vu.logger.Debugf("vacancy created successfully with id %d", createdVacancyID)

        updatedVacancy, err := vu.vacanciesRepository.GetByID(createdVacancyID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while getting from db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">vu.logger.Debugf("got updated vacancy with id %d", createdVacancyID)
        return updatedVacancy, nil</span>
}

func (vu *VacanciesUsecase) GetVacancy(ID uint64) (*dto.JSONVacancy, error) <span class="cov0" title="0">{
        vacancy, err := vu.vacanciesRepository.GetByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while getting from db got err %s", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return vacancy, nil</span>
}

func (vu *VacanciesUsecase) UpdateVacancy(ID uint64, vacancy *dto.JSONVacancy, currentUser *dto.SessionUser) (*dto.JSONVacancy, error) <span class="cov0" title="0">{
        vu.logger.WithFields(logrus.Fields{"employer_id": currentUser.ID, "user_type": currentUser.UserType}).Debug("got update request")
        oldVacancy, err := vu.vacanciesRepository.GetByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while getting from db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">vacancy.EmployerID = oldVacancy.EmployerID
        if vacancy.EmployerID != currentUser.ID </span><span class="cov0" title="0">{
                vu.logger.Debugf("not an owner tried to update vacancy, got %d expected %d", currentUser.ID, ID)
                return nil, fmt.Errorf(dto.MsgAccessDenied)
        }</span>

        <span class="cov0" title="0">updatedVacancy, err := vu.vacanciesRepository.Update(ID, vacancy)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while updating in db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">vu.logger.Debugf("successfully updated vacancy, got %d", updatedVacancy.ID)
        return updatedVacancy, nil</span>
}

func (vu *VacanciesUsecase) DeleteVacancy(ID uint64, currentUser *dto.SessionUser) error <span class="cov0" title="0">{
        vu.logger.WithFields(logrus.Fields{"employer_id": currentUser.ID, "user_type": currentUser.UserType}).Debug("got delete request")
        vacancy, err := vu.vacanciesRepository.GetByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while getting from db got err %s", err)
                return fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">if vacancy.EmployerID != currentUser.ID </span><span class="cov0" title="0">{
                vu.logger.Debugf("not an owner tried to delete vacancy, got %d expected %d", currentUser.ID, ID)
                return fmt.Errorf(dto.MsgAccessDenied)
        }</span>
        <span class="cov0" title="0">err = vu.vacanciesRepository.Delete(ID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while deleting from db got err %s", err)
                return fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">vu.logger.Debugf("successfully deleted vacancy with %d", ID)
        return nil</span>
}

func (vu *VacanciesUsecase) SubscribeOnVacancy(ID uint64, currentUser *dto.SessionUser) error <span class="cov0" title="0">{
        if currentUser == nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("user is not provided")
                return fmt.Errorf(dto.MsgUnauthorized)
        }</span>

        <span class="cov0" title="0">err := vu.vacanciesRepository.Subscribe(ID, currentUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while subscribing on db got err %s", err)
                return fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">vu.logger.Debugf("successfully subscribed on vacancy with ID: %d", ID)
        return nil</span>
}

func (vu *VacanciesUsecase) UnsubscribeFromVacancy(ID uint64, currentUser *dto.SessionUser) error <span class="cov0" title="0">{
        if currentUser == nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("user is not provided, currentUser = %v", currentUser)
                return fmt.Errorf(dto.MsgUnauthorized)
        }</span>

        <span class="cov0" title="0">err := vu.vacanciesRepository.Unsubscribe(ID, currentUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while unsubscribing on db got err %s", err)
                return fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">vu.logger.Debugf("successfully unsubscribed from vacancy with ID: %d", ID)
        return nil</span>
}

func (vu *VacanciesUsecase) GetSubscriptionInfo(ID, applicantID uint64) (*dto.JSONVacancySubscriptionStatus, error) <span class="cov0" title="0">{
        isApplicantSubscribed, err := vu.vacanciesRepository.GetSubscriptionStatus(ID, applicantID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while getting from db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>
        <span class="cov0" title="0">vu.logger.Debugf("got subscription status: %v, for vacancy %d and user %d", isApplicantSubscribed, ID, applicantID)
        return &amp;dto.JSONVacancySubscriptionStatus{
                ID:           ID,
                ApplicantID:  applicantID,
                IsSubscribed: isApplicantSubscribed,
        }, nil</span>
}

func (vu *VacanciesUsecase) GetVacancySubscribers(ID uint64, currentUser *dto.SessionUser) (*dto.JSONVacancySubscribers, error) <span class="cov0" title="0">{
        if currentUser == nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("user is not provided, currentUser = %v", currentUser)
                return nil, fmt.Errorf(dto.MsgUnauthorized)
        }</span>

        <span class="cov0" title="0">vacancy, err := vu.vacanciesRepository.GetByID(ID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while getting from db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>

        <span class="cov0" title="0">if currentUser.UserType != dto.UserTypeEmployer || currentUser.ID != vacancy.EmployerID </span><span class="cov0" title="0">{
                vu.logger.Errorf("user is not applicant, currentUser = %v", currentUser)
                return nil, fmt.Errorf(dto.MsgUnauthorized)
        }</span>

        <span class="cov0" title="0">subscribersModel, err := vu.vacanciesRepository.GetSubscribersList(ID)
        if err != nil </span><span class="cov0" title="0">{
                vu.logger.Errorf("while getting from db got err %s", err)
                return nil, fmt.Errorf(dto.MsgDataBaseError)
        }</span>

        <span class="cov0" title="0">subscribers := make([]*dto.JSONGetApplicantProfile, 0, len(subscribersModel))
        for _, subscriberModel := range subscribersModel </span><span class="cov0" title="0">{
                subscribers = append(subscribers, &amp;dto.JSONGetApplicantProfile{
                        ID:        subscriberModel.ID,
                        FirstName: subscriberModel.FirstName,
                        LastName:  subscriberModel.LastName,
                        City:      subscriberModel.CityName,
                        BirthDate: subscriberModel.BirthDate,
                        Avatar:    subscriberModel.PathToProfileAvatar,
                        Contacts:  subscriberModel.Contacts,
                        Education: subscriberModel.Education,
                })
        }</span>

        <span class="cov0" title="0">vu.logger.Debugf("successfully got %d subscribers for vacancy %d", len(subscribers), ID)
        return &amp;dto.JSONVacancySubscribers{
                ID:          ID,
                Subscribers: subscribers,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package utils

import (
        "fmt"
        "math/rand"
        "net/http"
        "time"

        "github.com/go-park-mail-ru/2024_2_VKatuny/internal/pkg/dto"
)

var (
        letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
)

const TokenLength = 32

// GenerateSessionTokenWithLength generate random string with given length for session id
func GenerateSessionToken(n int, userType string) string <span class="cov0" title="0">{
        b := make([]rune, n)

        for i := range b </span><span class="cov0" title="0">{
                b[i] = letterRunes[rand.Intn(len(letterRunes))]
        }</span>
        <span class="cov0" title="0">if userType == dto.UserTypeApplicant </span><span class="cov0" title="0">{
                return "1" + string(b)
        }</span>
        <span class="cov0" title="0">return "2" + string(b)</span>
}

func CheckToken(token string) (string, error) <span class="cov0" title="0">{
        if token[0] == '1' </span><span class="cov0" title="0">{
                return dto.UserTypeApplicant, nil
        }</span> else<span class="cov0" title="0"> if token[0] == '2' </span><span class="cov0" title="0">{
                return dto.UserTypeEmployer, nil
        }</span> else<span class="cov0" title="0"> {
                return "", fmt.Errorf("not our cookie")
        }</span>
}

func MakeAuthCookie(sessionID, backendAddress string) *http.Cookie <span class="cov0" title="0">{
        return &amp;http.Cookie{
                Name:     "session_id1", // why id1?
                Value:    sessionID,
                Expires:  time.Now().Add(10 * time.Hour),
                HttpOnly: true,
                //Secure:   true, // Enable when using HTTPS
                SameSite: http.SameSiteStrictMode,
                Domain:   backendAddress,
                Path:     "/api/v1",
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package utils

import "database/sql"

func GetDBConnection(DSN string) (*sql.DB, error) <span class="cov0" title="0">{ //conf DatabaseConfig) (*sql.DB, error) {
        db, err := sql.Open("pgx", DSN)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = db.Ping()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db.SetMaxOpenConns(10)
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package utils

import (
        "golang.org/x/crypto/bcrypt"
)

const (
        cost = 10
)

// HashPassword hashing password with cost og 10
func HashPassword(password string) string <span class="cov0" title="0">{
        bytePassword := []byte(password)
        hashedPassword, _ := bcrypt.GenerateFromPassword(bytePassword, cost)
        return string(hashedPassword[:])
}</span>

// EqualHashedPasswords returns true if first argument was hashed from second
func EqualHashedPasswords(passwordBD string, passwordFront string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(passwordBD), []byte(passwordFront))
        return err == nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
